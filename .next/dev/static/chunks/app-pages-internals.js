/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app-pages-internals"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fbuiltin%2Fglobal-error.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-segment.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fhttp-access-fallback%2Ferror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Flib%2Fframework%2Fboundary-components.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Flib%2Fmetadata%2Fgenerate%2Ficon-mark.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fnext-devtools%2Fuserspace%2Fapp%2Fsegment-explorer-node.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fbuiltin%2Fglobal-error.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-segment.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fhttp-access-fallback%2Ferror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Flib%2Fframework%2Fboundary-components.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Flib%2Fmetadata%2Fgenerate%2Ficon-mark.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fnext-devtools%2Fuserspace%2Fapp%2Fsegment-explorer-node.js%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/builtin/global-error.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/builtin/global-error.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/client-page.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/client-page.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/client-segment.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/client-segment.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/layout-router.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/render-from-template-context.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/render-from-template-context.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/lib/framework/boundary-components.js */ \"(app-pages-browser)/./node_modules/next/dist/lib/framework/boundary-components.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./node_modules/next/dist/lib/metadata/generate/icon-mark.js */ \"(app-pages-browser)/./node_modules/next/dist/lib/metadata/generate/icon-mark.js\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js */ \"(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js\", 23));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGaG9tZSUyRnJ1bm5lciUyRndvcmtzcGFjZSUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZkaXN0JTJGY2xpZW50JTJGY29tcG9uZW50cyUyRmJ1aWx0aW4lMkZnbG9iYWwtZXJyb3IuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGaG9tZSUyRnJ1bm5lciUyRndvcmtzcGFjZSUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZkaXN0JTJGY2xpZW50JTJGY29tcG9uZW50cyUyRmNsaWVudC1wYWdlLmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRmhvbWUlMkZydW5uZXIlMkZ3b3Jrc3BhY2UlMkZub2RlX21vZHVsZXMlMkZuZXh0JTJGZGlzdCUyRmNsaWVudCUyRmNvbXBvbmVudHMlMkZjbGllbnQtc2VnbWVudC5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZob21lJTJGcnVubmVyJTJGd29ya3NwYWNlJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGaHR0cC1hY2Nlc3MtZmFsbGJhY2slMkZlcnJvci1ib3VuZGFyeS5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZob21lJTJGcnVubmVyJTJGd29ya3NwYWNlJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGbGF5b3V0LXJvdXRlci5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZob21lJTJGcnVubmVyJTJGd29ya3NwYWNlJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZob21lJTJGcnVubmVyJTJGd29ya3NwYWNlJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZsaWIlMkZmcmFtZXdvcmslMkZib3VuZGFyeS1jb21wb25lbnRzLmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRmhvbWUlMkZydW5uZXIlMkZ3b3Jrc3BhY2UlMkZub2RlX21vZHVsZXMlMkZuZXh0JTJGZGlzdCUyRmxpYiUyRm1ldGFkYXRhJTJGZ2VuZXJhdGUlMkZpY29uLW1hcmsuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGaG9tZSUyRnJ1bm5lciUyRndvcmtzcGFjZSUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZkaXN0JTJGbmV4dC1kZXZ0b29scyUyRnVzZXJzcGFjZSUyRmFwcCUyRnNlZ21lbnQtZXhwbG9yZXItbm9kZS5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLG9RQUE0SDtBQUM1SDtBQUNBLGtQQUFtSDtBQUNuSDtBQUNBLHdQQUFzSDtBQUN0SDtBQUNBLGtTQUEySTtBQUMzSTtBQUNBLHNQQUFxSDtBQUNySDtBQUNBLG9SQUFvSTtBQUNwSTtBQUNBLDBQQUF1SDtBQUN2SDtBQUNBLGdQQUFxSDtBQUNySDtBQUNBLDBSQUF1SSIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2J1aWx0aW4vZ2xvYmFsLWVycm9yLmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvY2xpZW50LXBhZ2UuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9jbGllbnQtc2VnbWVudC5qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2h0dHAtYWNjZXNzLWZhbGxiYWNrL2Vycm9yLWJvdW5kYXJ5LmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbGF5b3V0LXJvdXRlci5qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9saWIvZnJhbWV3b3JrL2JvdW5kYXJ5LWNvbXBvbmVudHMuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9saWIvbWV0YWRhdGEvZ2VuZXJhdGUvaWNvbi1tYXJrLmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL3NlZ21lbnQtZXhwbG9yZXItbm9kZS5qc1wiKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fbuiltin%2Fglobal-error.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-segment.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fhttp-access-fallback%2Ferror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Flib%2Fframework%2Fboundary-components.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Flib%2Fmetadata%2Fgenerate%2Ficon-mark.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fnext-devtools%2Fuserspace%2Fapp%2Fsegment-explorer-node.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/bfcache.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/client/components/bfcache.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useRouterBFCache\", ({\n    enumerable: true,\n    get: function() {\n        return useRouterBFCache;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n// When the flag is disabled, only track the currently active tree\nconst MAX_BF_CACHE_ENTRIES =  false ? 0 : 1;\nfunction useRouterBFCache(activeTree, activeStateKey) {\n    // The currently active entry. The entries form a linked list, sorted in\n    // order of most recently active. This allows us to reuse parts of the list\n    // without cloning, unless there's a reordering or removal.\n    // TODO: Once we start tracking back/forward history at each route level,\n    // we should use the history order instead. In other words, when traversing\n    // to an existing entry as a result of a popstate event, we should maintain\n    // the existing order instead of moving it to the front of the list. I think\n    // an initial implementation of this could be to pass an incrementing id\n    // to history.pushState/replaceState, then use that here for ordering.\n    const [prevActiveEntry, setPrevActiveEntry] = (0, _react.useState)(()=>{\n        const initialEntry = {\n            tree: activeTree,\n            stateKey: activeStateKey,\n            next: null\n        };\n        return initialEntry;\n    });\n    if (prevActiveEntry.tree === activeTree) {\n        // Fast path. The active tree hasn't changed, so we can reuse the\n        // existing state.\n        return prevActiveEntry;\n    }\n    // The route tree changed. Note that this doesn't mean that the tree changed\n    // *at this level* — the change may be due to a child route. Either way, we\n    // need to either add or update the router tree in the bfcache.\n    //\n    // The rest of the code looks more complicated than it actually is because we\n    // can't mutate the state in place; we have to copy-on-write.\n    // Create a new entry for the active cache key. This is the head of the new\n    // linked list.\n    const newActiveEntry = {\n        tree: activeTree,\n        stateKey: activeStateKey,\n        next: null\n    };\n    // We need to append the old list onto the new list. If the head of the new\n    // list was already present in the cache, then we'll need to clone everything\n    // that came before it. Then we can reuse the rest.\n    let n = 1;\n    let oldEntry = prevActiveEntry;\n    let clonedEntry = newActiveEntry;\n    while(oldEntry !== null && n < MAX_BF_CACHE_ENTRIES){\n        if (oldEntry.stateKey === activeStateKey) {\n            // Fast path. This entry in the old list that corresponds to the key that\n            // is now active. We've already placed a clone of this entry at the front\n            // of the new list. We can reuse the rest of the old list without cloning.\n            // NOTE: We don't need to worry about eviction in this case because we\n            // haven't increased the size of the cache, and we assume the max size\n            // is constant across renders. If we were to change it to a dynamic limit,\n            // then the implementation would need to account for that.\n            clonedEntry.next = oldEntry.next;\n            break;\n        } else {\n            // Clone the entry and append it to the list.\n            n++;\n            const entry = {\n                tree: oldEntry.tree,\n                stateKey: oldEntry.stateKey,\n                next: null\n            };\n            clonedEntry.next = entry;\n            clonedEntry = entry;\n        }\n        oldEntry = oldEntry.next;\n    }\n    setPrevActiveEntry(newActiveEntry);\n    return newActiveEntry;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=bfcache.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYmZjYWNoZS5qcyIsIm1hcHBpbmdzIjoiOzs7O29EQWlDZ0JBOzs7ZUFBQUE7OzttQ0FoQ1M7QUFFekIsa0VBQWtFO0FBQ2xFLE1BQU1DLHVCQUF1QkMsTUFBbUMsR0FBRyxDQUFDLEdBQUc7QUE2QmhFLFNBQVNGLGlCQUNkSyxVQUE2QixFQUM3QkMsY0FBc0I7SUFFdEIsd0VBQXdFO0lBQ3hFLDJFQUEyRTtJQUMzRSwyREFBMkQ7SUFDM0QseUVBQXlFO0lBQ3pFLDJFQUEyRTtJQUMzRSwyRUFBMkU7SUFDM0UsNEVBQTRFO0lBQzVFLHdFQUF3RTtJQUN4RSxzRUFBc0U7SUFDdEUsTUFBTSxDQUFDQyxpQkFBaUJDLG1CQUFtQixHQUFHQyxDQUFBQSxHQUFBQSxPQUFBQSxRQUFBQSxFQUM1QztRQUNFLE1BQU1DLGVBQW1DO1lBQ3ZDQyxNQUFNTjtZQUNOTyxVQUFVTjtZQUNWTyxNQUFNO1FBQ1I7UUFDQSxPQUFPSDtJQUNUO0lBR0YsSUFBSUgsZ0JBQWdCSSxJQUFJLEtBQUtOLFlBQVk7UUFDdkMsaUVBQWlFO1FBQ2pFLGtCQUFrQjtRQUNsQixPQUFPRTtJQUNUO0lBRUEsNEVBQTRFO0lBQzVFLDJFQUEyRTtJQUMzRSwrREFBK0Q7SUFDL0QsRUFBRTtJQUNGLDZFQUE2RTtJQUM3RSw2REFBNkQ7SUFFN0QsMkVBQTJFO0lBQzNFLGVBQWU7SUFDZixNQUFNTyxpQkFBcUM7UUFDekNILE1BQU1OO1FBQ05PLFVBQVVOO1FBQ1ZPLE1BQU07SUFDUjtJQUVBLDJFQUEyRTtJQUMzRSw2RUFBNkU7SUFDN0UsbURBQW1EO0lBQ25ELElBQUlFLElBQUk7SUFDUixJQUFJQyxXQUFzQ1Q7SUFDMUMsSUFBSVUsY0FBa0NIO0lBQ3RDLE1BQU9FLGFBQWEsUUFBUUQsSUFBSWQscUJBQXNCO1FBQ3BELElBQUllLFNBQVNKLFFBQVEsS0FBS04sZ0JBQWdCO1lBQ3hDLHlFQUF5RTtZQUN6RSx5RUFBeUU7WUFDekUsMEVBQTBFO1lBQzFFLHNFQUFzRTtZQUN0RSxzRUFBc0U7WUFDdEUsMEVBQTBFO1lBQzFFLDBEQUEwRDtZQUMxRFcsWUFBWUosSUFBSSxHQUFHRyxTQUFTSCxJQUFJO1lBQ2hDO1FBQ0YsT0FBTztZQUNMLDZDQUE2QztZQUM3Q0U7WUFDQSxNQUFNRyxRQUE0QjtnQkFDaENQLE1BQU1LLFNBQVNMLElBQUk7Z0JBQ25CQyxVQUFVSSxTQUFTSixRQUFRO2dCQUMzQkMsTUFBTTtZQUNSO1lBQ0FJLFlBQVlKLElBQUksR0FBR0s7WUFDbkJELGNBQWNDO1FBQ2hCO1FBQ0FGLFdBQVdBLFNBQVNILElBQUk7SUFDMUI7SUFFQUwsbUJBQW1CTTtJQUNuQixPQUFPQTtBQUNUIiwic291cmNlcyI6WyIvc3JjL2NsaWVudC9jb21wb25lbnRzL2JmY2FjaGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBGbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci10eXBlcydcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5cbi8vIFdoZW4gdGhlIGZsYWcgaXMgZGlzYWJsZWQsIG9ubHkgdHJhY2sgdGhlIGN1cnJlbnRseSBhY3RpdmUgdHJlZVxuY29uc3QgTUFYX0JGX0NBQ0hFX0VOVFJJRVMgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0FDSEVfQ09NUE9ORU5UUyA/IDMgOiAxXG5cbmV4cG9ydCB0eXBlIFJvdXRlckJGQ2FjaGVFbnRyeSA9IHtcbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgc3RhdGVLZXk6IHN0cmluZ1xuICAvLyBUaGUgZW50cmllcyBmb3JtIGEgbGlua2VkIGxpc3QsIHNvcnRlZCBpbiBvcmRlciBvZiBtb3N0IHJlY2VudGx5IGFjdGl2ZS5cbiAgbmV4dDogUm91dGVyQkZDYWNoZUVudHJ5IHwgbnVsbFxufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBtb3N0IHJlY2VudCBOIHRyZWVzIChGbGlnaHRSb3V0ZXJTdGF0ZXMpIHRoYXQgd2VyZSBhY3RpdmVcbiAqIGF0IGEgY2VydGFpbiBzZWdtZW50IGxldmVsLiBFLmcuIGZvciBhIHNlZ21lbnQgXCIvYS9iL1twYXJhbV1cIiwgdGhpcyBob29rXG4gKiB0cmFja3MgdGhlIGxhc3QgTiBwYXJhbSB2YWx1ZXMgdGhhdCB0aGUgcm91dGVyIHJlbmRlcmVkIGZvciBOLlxuICpcbiAqIFRoZSByZXN1bHQgb2YgdGhpcyBob29rIHByZWNpc2VseSBkZXRlcm1pbmVzIHRoZSBudW1iZXIgYW5kIG9yZGVyIG9mXG4gKiB0cmVlcyB0aGF0IGFyZSByZW5kZXJlZCBpbiBwYXJhbGxlbCBhdCB0aGVpciBzZWdtZW50IGxldmVsLlxuICpcbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgY2FjaGUgaXMgdG8gd2UgY2FuIHByZXNlcnZlIHRoZSBSZWFjdCBhbmQgRE9NIHN0YXRlIG9mXG4gKiBzb21lIG51bWJlciBvZiBpbmFjdGl2ZSB0cmVlcywgYnkgcmVuZGVyaW5nIHRoZW0gaW4gYW4gPEFjdGl2aXR5PiBib3VuZGFyeS5cbiAqIFRoYXQgbWVhbnMgaXQgd291bGQgbm90IG1ha2Ugc2Vuc2UgZm9yIHRoZSB0aGUgbGlmZXRpbWUgb2YgdGhlIGNhY2hlIHRvIGJlXG4gKiBhbnkgbG9uZ2VyIHRoYW4gdGhlIGxpZmV0aW1lIG9mIHRoZSBSZWFjdCB0cmVlOyBlLmcuIGlmIHRoZSBob29rIHdlcmVcbiAqIHVubW91bnRlZCwgdGhlbiB0aGUgUmVhY3QgdHJlZSB3b3VsZCBiZSwgdG9vLiBTbywgd2UgdXNlIFJlYWN0IHN0YXRlIHRvXG4gKiBtYW5hZ2UgaXQuXG4gKlxuICogTm90ZSB0aGF0IHdlIGRvbid0IHN0b3JlIHRoZSBSU0MgZGF0YSBmb3IgdGhlIGNhY2hlIGVudHJpZXMgaW4gdGhpcyBob29rIOKAlFxuICogdGhlIGRhdGEgZm9yIGluYWN0aXZlIHNlZ21lbnRzIGlzIHN0b3JlZCBpbiB0aGUgcGFyZW50IENhY2hlTm9kZSwgd2hpY2hcbiAqICpkb2VzKiBoYXZlIGEgbG9uZ2VyIGxpZmV0aW1lIHRoYW4gdGhlIFJlYWN0IHRyZWUuIFRoaXMgaG9vayBvbmx5IGRldGVybWluZXNcbiAqIHdoaWNoIG9mIHRob3NlIHRyZWVzIHNob3VsZCBoYXZlIHRoZWlyICpzdGF0ZSogcHJlc2VydmVkLCBieSA8QWN0aXZpdHk+LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUm91dGVyQkZDYWNoZShcbiAgYWN0aXZlVHJlZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIGFjdGl2ZVN0YXRlS2V5OiBzdHJpbmdcbik6IFJvdXRlckJGQ2FjaGVFbnRyeSB7XG4gIC8vIFRoZSBjdXJyZW50bHkgYWN0aXZlIGVudHJ5LiBUaGUgZW50cmllcyBmb3JtIGEgbGlua2VkIGxpc3QsIHNvcnRlZCBpblxuICAvLyBvcmRlciBvZiBtb3N0IHJlY2VudGx5IGFjdGl2ZS4gVGhpcyBhbGxvd3MgdXMgdG8gcmV1c2UgcGFydHMgb2YgdGhlIGxpc3RcbiAgLy8gd2l0aG91dCBjbG9uaW5nLCB1bmxlc3MgdGhlcmUncyBhIHJlb3JkZXJpbmcgb3IgcmVtb3ZhbC5cbiAgLy8gVE9ETzogT25jZSB3ZSBzdGFydCB0cmFja2luZyBiYWNrL2ZvcndhcmQgaGlzdG9yeSBhdCBlYWNoIHJvdXRlIGxldmVsLFxuICAvLyB3ZSBzaG91bGQgdXNlIHRoZSBoaXN0b3J5IG9yZGVyIGluc3RlYWQuIEluIG90aGVyIHdvcmRzLCB3aGVuIHRyYXZlcnNpbmdcbiAgLy8gdG8gYW4gZXhpc3RpbmcgZW50cnkgYXMgYSByZXN1bHQgb2YgYSBwb3BzdGF0ZSBldmVudCwgd2Ugc2hvdWxkIG1haW50YWluXG4gIC8vIHRoZSBleGlzdGluZyBvcmRlciBpbnN0ZWFkIG9mIG1vdmluZyBpdCB0byB0aGUgZnJvbnQgb2YgdGhlIGxpc3QuIEkgdGhpbmtcbiAgLy8gYW4gaW5pdGlhbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGNvdWxkIGJlIHRvIHBhc3MgYW4gaW5jcmVtZW50aW5nIGlkXG4gIC8vIHRvIGhpc3RvcnkucHVzaFN0YXRlL3JlcGxhY2VTdGF0ZSwgdGhlbiB1c2UgdGhhdCBoZXJlIGZvciBvcmRlcmluZy5cbiAgY29uc3QgW3ByZXZBY3RpdmVFbnRyeSwgc2V0UHJldkFjdGl2ZUVudHJ5XSA9IHVzZVN0YXRlPFJvdXRlckJGQ2FjaGVFbnRyeT4oXG4gICAgKCkgPT4ge1xuICAgICAgY29uc3QgaW5pdGlhbEVudHJ5OiBSb3V0ZXJCRkNhY2hlRW50cnkgPSB7XG4gICAgICAgIHRyZWU6IGFjdGl2ZVRyZWUsXG4gICAgICAgIHN0YXRlS2V5OiBhY3RpdmVTdGF0ZUtleSxcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbml0aWFsRW50cnlcbiAgICB9XG4gIClcblxuICBpZiAocHJldkFjdGl2ZUVudHJ5LnRyZWUgPT09IGFjdGl2ZVRyZWUpIHtcbiAgICAvLyBGYXN0IHBhdGguIFRoZSBhY3RpdmUgdHJlZSBoYXNuJ3QgY2hhbmdlZCwgc28gd2UgY2FuIHJldXNlIHRoZVxuICAgIC8vIGV4aXN0aW5nIHN0YXRlLlxuICAgIHJldHVybiBwcmV2QWN0aXZlRW50cnlcbiAgfVxuXG4gIC8vIFRoZSByb3V0ZSB0cmVlIGNoYW5nZWQuIE5vdGUgdGhhdCB0aGlzIGRvZXNuJ3QgbWVhbiB0aGF0IHRoZSB0cmVlIGNoYW5nZWRcbiAgLy8gKmF0IHRoaXMgbGV2ZWwqIOKAlCB0aGUgY2hhbmdlIG1heSBiZSBkdWUgdG8gYSBjaGlsZCByb3V0ZS4gRWl0aGVyIHdheSwgd2VcbiAgLy8gbmVlZCB0byBlaXRoZXIgYWRkIG9yIHVwZGF0ZSB0aGUgcm91dGVyIHRyZWUgaW4gdGhlIGJmY2FjaGUuXG4gIC8vXG4gIC8vIFRoZSByZXN0IG9mIHRoZSBjb2RlIGxvb2tzIG1vcmUgY29tcGxpY2F0ZWQgdGhhbiBpdCBhY3R1YWxseSBpcyBiZWNhdXNlIHdlXG4gIC8vIGNhbid0IG11dGF0ZSB0aGUgc3RhdGUgaW4gcGxhY2U7IHdlIGhhdmUgdG8gY29weS1vbi13cml0ZS5cblxuICAvLyBDcmVhdGUgYSBuZXcgZW50cnkgZm9yIHRoZSBhY3RpdmUgY2FjaGUga2V5LiBUaGlzIGlzIHRoZSBoZWFkIG9mIHRoZSBuZXdcbiAgLy8gbGlua2VkIGxpc3QuXG4gIGNvbnN0IG5ld0FjdGl2ZUVudHJ5OiBSb3V0ZXJCRkNhY2hlRW50cnkgPSB7XG4gICAgdHJlZTogYWN0aXZlVHJlZSxcbiAgICBzdGF0ZUtleTogYWN0aXZlU3RhdGVLZXksXG4gICAgbmV4dDogbnVsbCxcbiAgfVxuXG4gIC8vIFdlIG5lZWQgdG8gYXBwZW5kIHRoZSBvbGQgbGlzdCBvbnRvIHRoZSBuZXcgbGlzdC4gSWYgdGhlIGhlYWQgb2YgdGhlIG5ld1xuICAvLyBsaXN0IHdhcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhlIGNhY2hlLCB0aGVuIHdlJ2xsIG5lZWQgdG8gY2xvbmUgZXZlcnl0aGluZ1xuICAvLyB0aGF0IGNhbWUgYmVmb3JlIGl0LiBUaGVuIHdlIGNhbiByZXVzZSB0aGUgcmVzdC5cbiAgbGV0IG4gPSAxXG4gIGxldCBvbGRFbnRyeTogUm91dGVyQkZDYWNoZUVudHJ5IHwgbnVsbCA9IHByZXZBY3RpdmVFbnRyeVxuICBsZXQgY2xvbmVkRW50cnk6IFJvdXRlckJGQ2FjaGVFbnRyeSA9IG5ld0FjdGl2ZUVudHJ5XG4gIHdoaWxlIChvbGRFbnRyeSAhPT0gbnVsbCAmJiBuIDwgTUFYX0JGX0NBQ0hFX0VOVFJJRVMpIHtcbiAgICBpZiAob2xkRW50cnkuc3RhdGVLZXkgPT09IGFjdGl2ZVN0YXRlS2V5KSB7XG4gICAgICAvLyBGYXN0IHBhdGguIFRoaXMgZW50cnkgaW4gdGhlIG9sZCBsaXN0IHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGtleSB0aGF0XG4gICAgICAvLyBpcyBub3cgYWN0aXZlLiBXZSd2ZSBhbHJlYWR5IHBsYWNlZCBhIGNsb25lIG9mIHRoaXMgZW50cnkgYXQgdGhlIGZyb250XG4gICAgICAvLyBvZiB0aGUgbmV3IGxpc3QuIFdlIGNhbiByZXVzZSB0aGUgcmVzdCBvZiB0aGUgb2xkIGxpc3Qgd2l0aG91dCBjbG9uaW5nLlxuICAgICAgLy8gTk9URTogV2UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCBldmljdGlvbiBpbiB0aGlzIGNhc2UgYmVjYXVzZSB3ZVxuICAgICAgLy8gaGF2ZW4ndCBpbmNyZWFzZWQgdGhlIHNpemUgb2YgdGhlIGNhY2hlLCBhbmQgd2UgYXNzdW1lIHRoZSBtYXggc2l6ZVxuICAgICAgLy8gaXMgY29uc3RhbnQgYWNyb3NzIHJlbmRlcnMuIElmIHdlIHdlcmUgdG8gY2hhbmdlIGl0IHRvIGEgZHluYW1pYyBsaW1pdCxcbiAgICAgIC8vIHRoZW4gdGhlIGltcGxlbWVudGF0aW9uIHdvdWxkIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhhdC5cbiAgICAgIGNsb25lZEVudHJ5Lm5leHQgPSBvbGRFbnRyeS5uZXh0XG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDbG9uZSB0aGUgZW50cnkgYW5kIGFwcGVuZCBpdCB0byB0aGUgbGlzdC5cbiAgICAgIG4rK1xuICAgICAgY29uc3QgZW50cnk6IFJvdXRlckJGQ2FjaGVFbnRyeSA9IHtcbiAgICAgICAgdHJlZTogb2xkRW50cnkudHJlZSxcbiAgICAgICAgc3RhdGVLZXk6IG9sZEVudHJ5LnN0YXRlS2V5LFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgfVxuICAgICAgY2xvbmVkRW50cnkubmV4dCA9IGVudHJ5XG4gICAgICBjbG9uZWRFbnRyeSA9IGVudHJ5XG4gICAgfVxuICAgIG9sZEVudHJ5ID0gb2xkRW50cnkubmV4dFxuICB9XG5cbiAgc2V0UHJldkFjdGl2ZUVudHJ5KG5ld0FjdGl2ZUVudHJ5KVxuICByZXR1cm4gbmV3QWN0aXZlRW50cnlcbn1cbiJdLCJuYW1lcyI6WyJ1c2VSb3V0ZXJCRkNhY2hlIiwiTUFYX0JGX0NBQ0hFX0VOVFJJRVMiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0NBQ0hFX0NPTVBPTkVOVFMiLCJhY3RpdmVUcmVlIiwiYWN0aXZlU3RhdGVLZXkiLCJwcmV2QWN0aXZlRW50cnkiLCJzZXRQcmV2QWN0aXZlRW50cnkiLCJ1c2VTdGF0ZSIsImluaXRpYWxFbnRyeSIsInRyZWUiLCJzdGF0ZUtleSIsIm5leHQiLCJuZXdBY3RpdmVFbnRyeSIsIm4iLCJvbGRFbnRyeSIsImNsb25lZEVudHJ5IiwiZW50cnkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/bfcache.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/client-page.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/client/components/client-page.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ClientPageRoot\", ({\n    enumerable: true,\n    get: function() {\n        return ClientPageRoot;\n    }\n}));\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _routeparams = __webpack_require__(/*! ../route-params */ \"(app-pages-browser)/./node_modules/next/dist/client/route-params.js\");\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../../shared/lib/hooks-client-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nfunction ClientPageRoot({ Component, serverProvidedParams }) {\n    let searchParams;\n    let params;\n    if (serverProvidedParams !== null) {\n        searchParams = serverProvidedParams.searchParams;\n        params = serverProvidedParams.params;\n    } else {\n        // When Cache Components is enabled, the server does not pass the params as\n        // props; they are parsed on the client and passed via context.\n        const layoutRouterContext = (0, _react.use)(_approutercontextsharedruntime.LayoutRouterContext);\n        params = layoutRouterContext !== null ? layoutRouterContext.parentParams : {};\n        // This is an intentional behavior change: when Cache Components is enabled,\n        // client segments receive the \"canonical\" search params, not the\n        // rewritten ones. Users should either call useSearchParams directly or pass\n        // the rewritten ones in from a Server Component.\n        // TODO: Log a deprecation error when this object is accessed\n        searchParams = (0, _routeparams.urlSearchParamsToParsedUrlQuery)((0, _react.use)(_hooksclientcontextsharedruntime.SearchParamsContext));\n    }\n    if (false) {} else {\n        const { createRenderSearchParamsFromClient } = __webpack_require__(/*! ../request/search-params.browser */ \"(app-pages-browser)/./node_modules/next/dist/client/request/search-params.browser.js\");\n        const clientSearchParams = createRenderSearchParamsFromClient(searchParams);\n        const { createRenderParamsFromClient } = __webpack_require__(/*! ../request/params.browser */ \"(app-pages-browser)/./node_modules/next/dist/client/request/params.browser.js\");\n        const clientParams = createRenderParamsFromClient(params);\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {\n            params: clientParams,\n            searchParams: clientSearchParams\n        });\n    }\n}\n_c = ClientPageRoot;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=client-page.js.map\nvar _c;\n$RefreshReg$(_c, \"ClientPageRoot\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvY2xpZW50LXBhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7OztrREFtQmdCQTs7O2VBQUFBOzs7OzRDQWhCZTsyREFHSzttQ0FDaEI7eUNBQzRCOzZEQUNaO0FBVTdCLHdCQUF3QixFQUM3QkMsU0FBUyxFQUNUQyxvQkFBb0IsRUFRckI7SUFDQyxJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUYseUJBQXlCLE1BQU07UUFDakNDLGVBQWVELHFCQUFxQkMsWUFBWTtRQUNoREMsU0FBU0YscUJBQXFCRSxNQUFNO0lBQ3RDLE9BQU87UUFDTCwyRUFBMkU7UUFDM0UsK0RBQStEO1FBQy9ELE1BQU1DLHNCQUFzQkMsQ0FBQUEsR0FBQUEsT0FBQUEsR0FBQUEsRUFBSUMsK0JBQUFBLG1CQUFtQjtRQUNuREgsU0FDRUMsd0JBQXdCLE9BQU9BLG9CQUFvQkcsWUFBWSxHQUFHLENBQUM7UUFFckUsNEVBQTRFO1FBQzVFLGlFQUFpRTtRQUNqRSw0RUFBNEU7UUFDNUUsaURBQWlEO1FBQ2pELDZEQUE2RDtRQUM3REwsZUFBZU0sQ0FBQUEsR0FBQUEsYUFBQUEsK0JBQUFBLEVBQWdDSCxDQUFBQSxHQUFBQSxPQUFBQSxHQUFBQSxFQUFJSSxpQ0FBQUEsbUJBQW1CO0lBQ3hFO0lBRUEsSUFBSSxLQUE2QixFQUFFLEVBd0JsQyxNQUFNO1FBQ0wsTUFBTSxFQUFFVyxrQ0FBa0MsRUFBRSxHQUMxQ1IsbUJBQU9BLENBQUMsOEhBQWtDO1FBQzVDLE1BQU1DLHFCQUFxQk8sbUNBQW1DbEI7UUFDOUQsTUFBTSxFQUFFbUIsNEJBQTRCLEVBQUUsR0FDcENULG1CQUFPQSxDQUFDLGdIQUEyQjtRQUNyQyxNQUFNRSxlQUFlTyw2QkFBNkJsQjtRQUVsRCxxQkFBTyxxQkFBQ0gsV0FBQUE7WUFBVUcsUUFBUVc7WUFBY1osY0FBY1c7O0lBQ3hEO0FBQ0Y7S0FqRWdCZCIsInNvdXJjZXMiOlsiL3NyYy9jbGllbnQvY29tcG9uZW50cy9jbGllbnQtcGFnZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB0eXBlIHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB7IEludmFyaWFudEVycm9yIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3InXG5cbmltcG9ydCB0eXBlIHsgUGFyYW1zIH0gZnJvbSAnLi4vLi4vc2VydmVyL3JlcXVlc3QvcGFyYW1zJ1xuaW1wb3J0IHsgTGF5b3V0Um91dGVyQ29udGV4dCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgdXNlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1cmxTZWFyY2hQYXJhbXNUb1BhcnNlZFVybFF1ZXJ5IH0gZnJvbSAnLi4vcm91dGUtcGFyYW1zJ1xuaW1wb3J0IHsgU2VhcmNoUGFyYW1zQ29udGV4dCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5cbi8qKlxuICogV2hlbiB0aGUgUGFnZSBpcyBhIGNsaWVudCBjb21wb25lbnQgd2Ugc2VuZCB0aGUgcGFyYW1zIGFuZCBzZWFyY2hQYXJhbXMgdG8gdGhpcyBjbGllbnQgd3JhcHBlclxuICogd2hlcmUgdGhleSBhcmUgdHVybmVkIGludG8gZHluYW1pY2FsbHkgdHJhY2tlZCB2YWx1ZXMgYmVmb3JlIGJlaW5nIHBhc3NlZCB0byB0aGUgYWN0dWFsIFBhZ2UgY29tcG9uZW50LlxuICpcbiAqIGFkZGl0aW9uYWxseSB3ZSBtYXkgc2VuZCBwcm9taXNlcyByZXByZXNlbnRpbmcgdGhlIHBhcmFtcyBhbmQgc2VhcmNoUGFyYW1zLiBXZSBkb24ndCBldmVyIHVzZSB0aGVzZSBwYXNzZWRcbiAqIHZhbHVlcyBidXQgaXQgY2FuIGJlIG5lY2Vzc2FyeSBmb3IgdGhlIHNlbmRlciB0byBzZW5kIGEgUHJvbWlzZSB0aGF0IGRvZXNuJ3QgcmVzb2x2ZSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMuXG4gKiBJdCBpcyB1cCB0byB0aGUgY2FsbGVyIHRvIGRlY2lkZSBpZiB0aGUgcHJvbWlzZXMgYXJlIG5lZWRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENsaWVudFBhZ2VSb290KHtcbiAgQ29tcG9uZW50LFxuICBzZXJ2ZXJQcm92aWRlZFBhcmFtcyxcbn06IHtcbiAgQ29tcG9uZW50OiBSZWFjdC5Db21wb25lbnRUeXBlPGFueT5cbiAgc2VydmVyUHJvdmlkZWRQYXJhbXM6IG51bGwgfCB7XG4gICAgc2VhcmNoUGFyYW1zOiBQYXJzZWRVcmxRdWVyeVxuICAgIHBhcmFtczogUGFyYW1zXG4gICAgcHJvbWlzZXM6IEFycmF5PFByb21pc2U8YW55Pj4gfCBudWxsXG4gIH1cbn0pIHtcbiAgbGV0IHNlYXJjaFBhcmFtczogUGFyc2VkVXJsUXVlcnlcbiAgbGV0IHBhcmFtczogUGFyYW1zXG4gIGlmIChzZXJ2ZXJQcm92aWRlZFBhcmFtcyAhPT0gbnVsbCkge1xuICAgIHNlYXJjaFBhcmFtcyA9IHNlcnZlclByb3ZpZGVkUGFyYW1zLnNlYXJjaFBhcmFtc1xuICAgIHBhcmFtcyA9IHNlcnZlclByb3ZpZGVkUGFyYW1zLnBhcmFtc1xuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gQ2FjaGUgQ29tcG9uZW50cyBpcyBlbmFibGVkLCB0aGUgc2VydmVyIGRvZXMgbm90IHBhc3MgdGhlIHBhcmFtcyBhc1xuICAgIC8vIHByb3BzOyB0aGV5IGFyZSBwYXJzZWQgb24gdGhlIGNsaWVudCBhbmQgcGFzc2VkIHZpYSBjb250ZXh0LlxuICAgIGNvbnN0IGxheW91dFJvdXRlckNvbnRleHQgPSB1c2UoTGF5b3V0Um91dGVyQ29udGV4dClcbiAgICBwYXJhbXMgPVxuICAgICAgbGF5b3V0Um91dGVyQ29udGV4dCAhPT0gbnVsbCA/IGxheW91dFJvdXRlckNvbnRleHQucGFyZW50UGFyYW1zIDoge31cblxuICAgIC8vIFRoaXMgaXMgYW4gaW50ZW50aW9uYWwgYmVoYXZpb3IgY2hhbmdlOiB3aGVuIENhY2hlIENvbXBvbmVudHMgaXMgZW5hYmxlZCxcbiAgICAvLyBjbGllbnQgc2VnbWVudHMgcmVjZWl2ZSB0aGUgXCJjYW5vbmljYWxcIiBzZWFyY2ggcGFyYW1zLCBub3QgdGhlXG4gICAgLy8gcmV3cml0dGVuIG9uZXMuIFVzZXJzIHNob3VsZCBlaXRoZXIgY2FsbCB1c2VTZWFyY2hQYXJhbXMgZGlyZWN0bHkgb3IgcGFzc1xuICAgIC8vIHRoZSByZXdyaXR0ZW4gb25lcyBpbiBmcm9tIGEgU2VydmVyIENvbXBvbmVudC5cbiAgICAvLyBUT0RPOiBMb2cgYSBkZXByZWNhdGlvbiBlcnJvciB3aGVuIHRoaXMgb2JqZWN0IGlzIGFjY2Vzc2VkXG4gICAgc2VhcmNoUGFyYW1zID0gdXJsU2VhcmNoUGFyYW1zVG9QYXJzZWRVcmxRdWVyeSh1c2UoU2VhcmNoUGFyYW1zQ29udGV4dCkhKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgeyB3b3JrQXN5bmNTdG9yYWdlIH0gPVxuICAgICAgcmVxdWlyZSgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJylcblxuICAgIGxldCBjbGllbnRTZWFyY2hQYXJhbXM6IFByb21pc2U8UGFyc2VkVXJsUXVlcnk+XG4gICAgbGV0IGNsaWVudFBhcmFtczogUHJvbWlzZTxQYXJhbXM+XG4gICAgLy8gV2UgYXJlIGdvaW5nIHRvIGluc3RydW1lbnQgdGhlIHNlYXJjaFBhcmFtcyBwcm9wIHdpdGggdHJhY2tpbmcgZm9yIHRoZVxuICAgIC8vIGFwcHJvcHJpYXRlIGNvbnRleHQuIFdlIHdyYXAgZGlmZmVyZW50bHkgaW4gcHJlcmVuZGVyaW5nIHZzIHJlbmRlcmluZ1xuICAgIGNvbnN0IHN0b3JlID0gd29ya0FzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gICAgaWYgKCFzdG9yZSkge1xuICAgICAgdGhyb3cgbmV3IEludmFyaWFudEVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgd29ya1N0b3JlIHRvIGV4aXN0IHdoZW4gaGFuZGxpbmcgc2VhcmNoUGFyYW1zIGluIGEgY2xpZW50IFBhZ2UuJ1xuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHsgY3JlYXRlU2VhcmNoUGFyYW1zRnJvbUNsaWVudCB9ID1cbiAgICAgIHJlcXVpcmUoJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3NlYXJjaC1wYXJhbXMnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9zZWFyY2gtcGFyYW1zJylcbiAgICBjbGllbnRTZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXNGcm9tQ2xpZW50KHNlYXJjaFBhcmFtcywgc3RvcmUpXG5cbiAgICBjb25zdCB7IGNyZWF0ZVBhcmFtc0Zyb21DbGllbnQgfSA9XG4gICAgICByZXF1aXJlKCcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnKVxuICAgIGNsaWVudFBhcmFtcyA9IGNyZWF0ZVBhcmFtc0Zyb21DbGllbnQocGFyYW1zLCBzdG9yZSlcblxuICAgIHJldHVybiA8Q29tcG9uZW50IHBhcmFtcz17Y2xpZW50UGFyYW1zfSBzZWFyY2hQYXJhbXM9e2NsaWVudFNlYXJjaFBhcmFtc30gLz5cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7IGNyZWF0ZVJlbmRlclNlYXJjaFBhcmFtc0Zyb21DbGllbnQgfSA9XG4gICAgICByZXF1aXJlKCcuLi9yZXF1ZXN0L3NlYXJjaC1wYXJhbXMuYnJvd3NlcicpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL3JlcXVlc3Qvc2VhcmNoLXBhcmFtcy5icm93c2VyJylcbiAgICBjb25zdCBjbGllbnRTZWFyY2hQYXJhbXMgPSBjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXNGcm9tQ2xpZW50KHNlYXJjaFBhcmFtcylcbiAgICBjb25zdCB7IGNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQgfSA9XG4gICAgICByZXF1aXJlKCcuLi9yZXF1ZXN0L3BhcmFtcy5icm93c2VyJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vcmVxdWVzdC9wYXJhbXMuYnJvd3NlcicpXG4gICAgY29uc3QgY2xpZW50UGFyYW1zID0gY3JlYXRlUmVuZGVyUGFyYW1zRnJvbUNsaWVudChwYXJhbXMpXG5cbiAgICByZXR1cm4gPENvbXBvbmVudCBwYXJhbXM9e2NsaWVudFBhcmFtc30gc2VhcmNoUGFyYW1zPXtjbGllbnRTZWFyY2hQYXJhbXN9IC8+XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJDbGllbnRQYWdlUm9vdCIsIkNvbXBvbmVudCIsInNlcnZlclByb3ZpZGVkUGFyYW1zIiwic2VhcmNoUGFyYW1zIiwicGFyYW1zIiwibGF5b3V0Um91dGVyQ29udGV4dCIsInVzZSIsIkxheW91dFJvdXRlckNvbnRleHQiLCJwYXJlbnRQYXJhbXMiLCJ1cmxTZWFyY2hQYXJhbXNUb1BhcnNlZFVybFF1ZXJ5IiwiU2VhcmNoUGFyYW1zQ29udGV4dCIsIndpbmRvdyIsIndvcmtBc3luY1N0b3JhZ2UiLCJyZXF1aXJlIiwiY2xpZW50U2VhcmNoUGFyYW1zIiwiY2xpZW50UGFyYW1zIiwic3RvcmUiLCJnZXRTdG9yZSIsIkludmFyaWFudEVycm9yIiwiY3JlYXRlU2VhcmNoUGFyYW1zRnJvbUNsaWVudCIsImNyZWF0ZVBhcmFtc0Zyb21DbGllbnQiLCJjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXNGcm9tQ2xpZW50IiwiY3JlYXRlUmVuZGVyUGFyYW1zRnJvbUNsaWVudCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/client-page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/client-segment.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/client-segment.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ClientSegmentRoot\", ({\n    enumerable: true,\n    get: function() {\n        return ClientSegmentRoot;\n    }\n}));\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nfunction ClientSegmentRoot({ Component, slots, serverProvidedParams }) {\n    let params;\n    if (serverProvidedParams !== null) {\n        params = serverProvidedParams.params;\n    } else {\n        // When Cache Components is enabled, the server does not pass the params\n        // as props; they are parsed on the client and passed via context.\n        const layoutRouterContext = (0, _react.use)(_approutercontextsharedruntime.LayoutRouterContext);\n        params = layoutRouterContext !== null ? layoutRouterContext.parentParams : {};\n    }\n    if (false) {} else {\n        const { createRenderParamsFromClient } = __webpack_require__(/*! ../request/params.browser */ \"(app-pages-browser)/./node_modules/next/dist/client/request/params.browser.js\");\n        const clientParams = createRenderParamsFromClient(params);\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {\n            ...slots,\n            params: clientParams\n        });\n    }\n}\n_c = ClientSegmentRoot;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=client-segment.js.map\nvar _c;\n$RefreshReg$(_c, \"ClientSegmentRoot\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvY2xpZW50LXNlZ21lbnQuanMiLCJtYXBwaW5ncyI6Ijs7OztxREFnQmdCQTs7O2VBQUFBOzs7OzRDQWRlOzJEQUdLO21DQUNoQjtBQVViLDJCQUEyQixFQUNoQ0MsU0FBUyxFQUNUQyxLQUFLLEVBQ0xDLG9CQUFvQixFQVFyQjtJQUNDLElBQUlDO0lBQ0osSUFBSUQseUJBQXlCLE1BQU07UUFDakNDLFNBQVNELHFCQUFxQkMsTUFBTTtJQUN0QyxPQUFPO1FBQ0wsd0VBQXdFO1FBQ3hFLGtFQUFrRTtRQUNsRSxNQUFNQyxzQkFBc0JDLENBQUFBLEdBQUFBLE9BQUFBLEdBQUFBLEVBQUlDLCtCQUFBQSxtQkFBbUI7UUFDbkRILFNBQ0VDLHdCQUF3QixPQUFPQSxvQkFBb0JHLFlBQVksR0FBRyxDQUFDO0lBQ3ZFO0lBRUEsSUFBSSxLQUE2QixFQUFFLEVBbUJsQyxNQUFNO1FBQ0wsTUFBTSxFQUFFUyw0QkFBNEIsRUFBRSxHQUNwQ04sbUJBQU9BLENBQUMsZ0hBQTJCO1FBQ3JDLE1BQU1DLGVBQWVLLDZCQUE2QmI7UUFDbEQscUJBQU8scUJBQUNILFdBQUFBO1lBQVcsR0FBR0MsS0FBSztZQUFFRSxRQUFRUTs7SUFDdkM7QUFDRjtLQWhEZ0JaIiwic291cmNlcyI6WyIvc3JjL2NsaWVudC9jb21wb25lbnRzL2NsaWVudC1zZWdtZW50LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgSW52YXJpYW50RXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2ludmFyaWFudC1lcnJvcidcblxuaW1wb3J0IHR5cGUgeyBQYXJhbXMgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnXG5pbXBvcnQgeyBMYXlvdXRSb3V0ZXJDb250ZXh0IH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyB1c2UgfSBmcm9tICdyZWFjdCdcblxuLyoqXG4gKiBXaGVuIHRoZSBQYWdlIGlzIGEgY2xpZW50IGNvbXBvbmVudCB3ZSBzZW5kIHRoZSBwYXJhbXMgdG8gdGhpcyBjbGllbnQgd3JhcHBlclxuICogd2hlcmUgdGhleSBhcmUgdHVybmVkIGludG8gZHluYW1pY2FsbHkgdHJhY2tlZCB2YWx1ZXMgYmVmb3JlIGJlaW5nIHBhc3NlZCB0byB0aGUgYWN0dWFsIFNlZ21lbnQgY29tcG9uZW50LlxuICpcbiAqIGFkZGl0aW9uYWxseSB3ZSBtYXkgc2VuZCBhIHByb21pc2UgcmVwcmVzZW50aW5nIHBhcmFtcy4gV2UgZG9uJ3QgZXZlciB1c2UgdGhpcyBwYXNzZWRcbiAqIHZhbHVlIGJ1dCBpdCBjYW4gYmUgbmVjZXNzYXJ5IGZvciB0aGUgc2VuZGVyIHRvIHNlbmQgYSBQcm9taXNlIHRoYXQgZG9lc24ndCByZXNvbHZlIGluIGNlcnRhaW4gc2l0dWF0aW9uc1xuICogc3VjaCBhcyB3aGVuIGNhY2hlQ29tcG9uZW50cyBpcyBlbmFibGVkLiBJdCBpcyB1cCB0byB0aGUgY2FsbGVyIHRvIGRlY2lkZSBpZiB0aGUgcHJvbWlzZXMgYXJlIG5lZWRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENsaWVudFNlZ21lbnRSb290KHtcbiAgQ29tcG9uZW50LFxuICBzbG90cyxcbiAgc2VydmVyUHJvdmlkZWRQYXJhbXMsXG59OiB7XG4gIENvbXBvbmVudDogUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+XG4gIHNsb3RzOiB7IFtrZXk6IHN0cmluZ106IFJlYWN0LlJlYWN0Tm9kZSB9XG4gIHNlcnZlclByb3ZpZGVkUGFyYW1zOiBudWxsIHwge1xuICAgIHBhcmFtczogUGFyYW1zXG4gICAgcHJvbWlzZXM6IEFycmF5PFByb21pc2U8YW55Pj4gfCBudWxsXG4gIH1cbn0pIHtcbiAgbGV0IHBhcmFtczogUGFyYW1zXG4gIGlmIChzZXJ2ZXJQcm92aWRlZFBhcmFtcyAhPT0gbnVsbCkge1xuICAgIHBhcmFtcyA9IHNlcnZlclByb3ZpZGVkUGFyYW1zLnBhcmFtc1xuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gQ2FjaGUgQ29tcG9uZW50cyBpcyBlbmFibGVkLCB0aGUgc2VydmVyIGRvZXMgbm90IHBhc3MgdGhlIHBhcmFtc1xuICAgIC8vIGFzIHByb3BzOyB0aGV5IGFyZSBwYXJzZWQgb24gdGhlIGNsaWVudCBhbmQgcGFzc2VkIHZpYSBjb250ZXh0LlxuICAgIGNvbnN0IGxheW91dFJvdXRlckNvbnRleHQgPSB1c2UoTGF5b3V0Um91dGVyQ29udGV4dClcbiAgICBwYXJhbXMgPVxuICAgICAgbGF5b3V0Um91dGVyQ29udGV4dCAhPT0gbnVsbCA/IGxheW91dFJvdXRlckNvbnRleHQucGFyZW50UGFyYW1zIDoge31cbiAgfVxuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IHsgd29ya0FzeW5jU3RvcmFnZSB9ID1cbiAgICAgIHJlcXVpcmUoJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCcpXG5cbiAgICBsZXQgY2xpZW50UGFyYW1zOiBQcm9taXNlPFBhcmFtcz5cbiAgICAvLyBXZSBhcmUgZ29pbmcgdG8gaW5zdHJ1bWVudCB0aGUgc2VhcmNoUGFyYW1zIHByb3Agd2l0aCB0cmFja2luZyBmb3IgdGhlXG4gICAgLy8gYXBwcm9wcmlhdGUgY29udGV4dC4gV2Ugd3JhcCBkaWZmZXJlbnRseSBpbiBwcmVyZW5kZXJpbmcgdnMgcmVuZGVyaW5nXG4gICAgY29uc3Qgc3RvcmUgPSB3b3JrQXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgICBpZiAoIXN0b3JlKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YXJpYW50RXJyb3IoXG4gICAgICAgICdFeHBlY3RlZCB3b3JrU3RvcmUgdG8gZXhpc3Qgd2hlbiBoYW5kbGluZyBwYXJhbXMgaW4gYSBjbGllbnQgc2VnbWVudCBzdWNoIGFzIGEgTGF5b3V0IG9yIFRlbXBsYXRlLidcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCB7IGNyZWF0ZVBhcmFtc0Zyb21DbGllbnQgfSA9XG4gICAgICByZXF1aXJlKCcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnKVxuICAgIGNsaWVudFBhcmFtcyA9IGNyZWF0ZVBhcmFtc0Zyb21DbGllbnQocGFyYW1zLCBzdG9yZSlcblxuICAgIHJldHVybiA8Q29tcG9uZW50IHsuLi5zbG90c30gcGFyYW1zPXtjbGllbnRQYXJhbXN9IC8+XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgeyBjcmVhdGVSZW5kZXJQYXJhbXNGcm9tQ2xpZW50IH0gPVxuICAgICAgcmVxdWlyZSgnLi4vcmVxdWVzdC9wYXJhbXMuYnJvd3NlcicpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL3JlcXVlc3QvcGFyYW1zLmJyb3dzZXInKVxuICAgIGNvbnN0IGNsaWVudFBhcmFtcyA9IGNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQocGFyYW1zKVxuICAgIHJldHVybiA8Q29tcG9uZW50IHsuLi5zbG90c30gcGFyYW1zPXtjbGllbnRQYXJhbXN9IC8+XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJDbGllbnRTZWdtZW50Um9vdCIsIkNvbXBvbmVudCIsInNsb3RzIiwic2VydmVyUHJvdmlkZWRQYXJhbXMiLCJwYXJhbXMiLCJsYXlvdXRSb3V0ZXJDb250ZXh0IiwidXNlIiwiTGF5b3V0Um91dGVyQ29udGV4dCIsInBhcmVudFBhcmFtcyIsIndpbmRvdyIsIndvcmtBc3luY1N0b3JhZ2UiLCJyZXF1aXJlIiwiY2xpZW50UGFyYW1zIiwic3RvcmUiLCJnZXRTdG9yZSIsIkludmFyaWFudEVycm9yIiwiY3JlYXRlUGFyYW1zRnJvbUNsaWVudCIsImNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/client-segment.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/layout-router.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return OuterLayoutRouter;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _fetchserverresponse = __webpack_require__(/*! ./router-reducer/fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _unresolvedthenable = __webpack_require__(/*! ./unresolved-thenable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/unresolved-thenable.js\");\nconst _errorboundary = __webpack_require__(/*! ./error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js\");\nconst _matchsegments = __webpack_require__(/*! ./match-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/match-segments.js\");\nconst _disablesmoothscroll = __webpack_require__(/*! ../../shared/lib/router/utils/disable-smooth-scroll */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js\");\nconst _redirectboundary = __webpack_require__(/*! ./redirect-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js\");\nconst _errorboundary1 = __webpack_require__(/*! ./http-access-fallback/error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js\");\nconst _createroutercachekey = __webpack_require__(/*! ./router-reducer/create-router-cache-key */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./router-reducer/reducers/has-interception-route-in-current-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\nconst _useactionqueue = __webpack_require__(/*! ./use-action-queue */ \"(app-pages-browser)/./node_modules/next/dist/client/components/use-action-queue.js\");\nconst _bfcache = __webpack_require__(/*! ./bfcache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/bfcache.js\");\nconst _apppaths = __webpack_require__(/*! ../../shared/lib/router/utils/app-paths */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/app-paths.js\");\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../../shared/lib/hooks-client-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nconst _routeparams = __webpack_require__(/*! ../route-params */ \"(app-pages-browser)/./node_modules/next/dist/client/route-params.js\");\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {\n    if (segmentPathToWalk) {\n        const [segment, parallelRouteKey] = segmentPathToWalk;\n        const isLast = segmentPathToWalk.length === 2;\n        if ((0, _matchsegments.matchSegment)(treeToRecreate[0], segment)) {\n            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n                if (isLast) {\n                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);\n                    return [\n                        treeToRecreate[0],\n                        {\n                            ...treeToRecreate[1],\n                            [parallelRouteKey]: [\n                                subTree[0],\n                                subTree[1],\n                                subTree[2],\n                                'refetch'\n                            ]\n                        }\n                    ];\n                }\n                return [\n                    treeToRecreate[0],\n                    {\n                        ...treeToRecreate[1],\n                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])\n                    }\n                ];\n            }\n        }\n    }\n    return treeToRecreate;\n}\nconst __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = _reactdom.default.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */ function findDOMNode(instance) {\n    // Tree-shake for server bundle\n    if (false) {}\n    // __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.\n    // We need to lazily reference it.\n    const internal_reactDOMfindDOMNode = __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode;\n    return internal_reactDOMfindDOMNode(instance);\n}\nconst rectProperties = [\n    'bottom',\n    'height',\n    'left',\n    'right',\n    'top',\n    'width',\n    'x',\n    'y'\n];\n/**\n * Check if a HTMLElement is hidden or fixed/sticky position\n */ function shouldSkipElement(element) {\n    // we ignore fixed or sticky positioned elements since they'll likely pass the \"in-viewport\" check\n    // and will result in a situation we bail on scroll because of something like a fixed nav,\n    // even though the actual page content is offscreen\n    if ([\n        'sticky',\n        'fixed'\n    ].includes(getComputedStyle(element).position)) {\n        return true;\n    }\n    // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\n    // because `offsetParent` doesn't consider document/body\n    const rect = element.getBoundingClientRect();\n    return rectProperties.every((item)=>rect[item] === 0);\n}\n/**\n * Check if the top corner of the HTMLElement is in the viewport.\n */ function topOfElementInViewport(element, viewportHeight) {\n    const rect = element.getBoundingClientRect();\n    return rect.top >= 0 && rect.top <= viewportHeight;\n}\n/**\n * Find the DOM node for a hash fragment.\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\n * If the hash fragment is an id, the page has to scroll to the element with that id.\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\n */ function getHashFragmentDomNode(hashFragment) {\n    // If the hash fragment is `top` the page has to scroll to the top of the page.\n    if (hashFragment === 'top') {\n        return document.body;\n    }\n    // If the hash fragment is an id, the page has to scroll to the element with that id.\n    return document.getElementById(hashFragment) ?? // If the hash fragment is a name, the page has to scroll to the first element with that name.\n    document.getElementsByName(hashFragment)[0];\n}\nclass InnerScrollAndFocusHandler extends _react.default.Component {\n    componentDidMount() {\n        this.handlePotentialScroll();\n    }\n    componentDidUpdate() {\n        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\n        if (this.props.focusAndScrollRef.apply) {\n            this.handlePotentialScroll();\n        }\n    }\n    render() {\n        return this.props.children;\n    }\n    constructor(...args){\n        super(...args), this.handlePotentialScroll = ()=>{\n            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n            const { focusAndScrollRef, segmentPath } = this.props;\n            if (focusAndScrollRef.apply) {\n                // segmentPaths is an array of segment paths that should be scrolled to\n                // if the current segment path is not in the array, the scroll is not applied\n                // unless the array is empty, in which case the scroll is always applied\n                if (focusAndScrollRef.segmentPaths.length !== 0 && !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=>segmentPath.every((segment, index)=>(0, _matchsegments.matchSegment)(segment, scrollRefSegmentPath[index])))) {\n                    return;\n                }\n                let domNode = null;\n                const hashFragment = focusAndScrollRef.hashFragment;\n                if (hashFragment) {\n                    domNode = getHashFragmentDomNode(hashFragment);\n                }\n                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n                // This already caused a bug where the first child was a <link/> in head.\n                if (!domNode) {\n                    domNode = findDOMNode(this);\n                }\n                // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\n                if (!(domNode instanceof Element)) {\n                    return;\n                }\n                // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.\n                // If the element is skipped, try to select the next sibling and try again.\n                while(!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)){\n                    if (true) {\n                        if (domNode.parentElement?.localName === 'head') {\n                        // TODO: We enter this state when metadata was rendered as part of the page or via Next.js.\n                        // This is always a bug in Next.js and caused by React hoisting metadata.\n                        // We need to replace `findDOMNode` in favor of Fragment Refs (when available) so that we can skip over metadata.\n                        }\n                    }\n                    // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.\n                    if (domNode.nextElementSibling === null) {\n                        return;\n                    }\n                    domNode = domNode.nextElementSibling;\n                }\n                // State is mutated to ensure that the focus and scroll is applied only once.\n                focusAndScrollRef.apply = false;\n                focusAndScrollRef.hashFragment = null;\n                focusAndScrollRef.segmentPaths = [];\n                (0, _disablesmoothscroll.disableSmoothScrollDuringRouteTransition)(()=>{\n                    // In case of hash scroll, we only need to scroll the element into view\n                    if (hashFragment) {\n                        ;\n                        domNode.scrollIntoView();\n                        return;\n                    }\n                    // Store the current viewport height because reading `clientHeight` causes a reflow,\n                    // and it won't change during this function.\n                    const htmlElement = document.documentElement;\n                    const viewportHeight = htmlElement.clientHeight;\n                    // If the element's top edge is already in the viewport, exit early.\n                    if (topOfElementInViewport(domNode, viewportHeight)) {\n                        return;\n                    }\n                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n                    htmlElement.scrollTop = 0;\n                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n                    if (!topOfElementInViewport(domNode, viewportHeight)) {\n                        // Scroll into view doesn't scroll horizontally by default when not needed\n                        ;\n                        domNode.scrollIntoView();\n                    }\n                }, {\n                    // We will force layout by querying domNode position\n                    dontForceLayout: true,\n                    onlyHashChange: focusAndScrollRef.onlyHashChange\n                });\n                // Mutate after scrolling so that it can be read by `disableSmoothScrollDuringRouteTransition`\n                focusAndScrollRef.onlyHashChange = false;\n                // Set focus on the element\n                domNode.focus();\n            }\n        };\n    }\n}\nfunction ScrollAndFocusHandler({ segmentPath, children }) {\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);\n    if (!context) {\n        throw Object.defineProperty(new Error('invariant global layout router not mounted'), \"__NEXT_ERROR_CODE\", {\n            value: \"E473\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(InnerScrollAndFocusHandler, {\n        segmentPath: segmentPath,\n        focusAndScrollRef: context.focusAndScrollRef,\n        children: children\n    });\n}\n_c = ScrollAndFocusHandler;\n/**\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\n */ function InnerLayoutRouter({ tree, segmentPath, debugNameContext, cacheNode, params, url, isActive }) {\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);\n    const parentNavPromises = (0, _react.useContext)(_hooksclientcontextsharedruntime.NavigationPromisesContext);\n    if (!context) {\n        throw Object.defineProperty(new Error('invariant global layout router not mounted'), \"__NEXT_ERROR_CODE\", {\n            value: \"E473\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const { tree: fullTree } = context;\n    // `rsc` represents the renderable node for this segment.\n    // If this segment has a `prefetchRsc`, it's the statically prefetched data.\n    // We should use that on initial render instead of `rsc`. Then we'll switch\n    // to `rsc` when the dynamic response streams in.\n    //\n    // If no prefetch data is available, then we go straight to rendering `rsc`.\n    const resolvedPrefetchRsc = cacheNode.prefetchRsc !== null ? cacheNode.prefetchRsc : cacheNode.rsc;\n    // We use `useDeferredValue` to handle switching between the prefetched and\n    // final values. The second argument is returned on initial render, then it\n    // re-renders with the first argument.\n    const rsc = (0, _react.useDeferredValue)(cacheNode.rsc, resolvedPrefetchRsc);\n    // `rsc` is either a React node or a promise for a React node, except we\n    // special case `null` to represent that this segment's data is missing. If\n    // it's a promise, we need to unwrap it so we can determine whether or not the\n    // data is missing.\n    const resolvedRsc = typeof rsc === 'object' && rsc !== null && typeof rsc.then === 'function' ? (0, _react.use)(rsc) : rsc;\n    if (!resolvedRsc) {\n        // The data for this segment is not available, and there's no pending\n        // navigation that will be able to fulfill it. We need to fetch more from\n        // the server and patch the cache.\n        // Only fetch data for the active segment. Inactive segments (rendered\n        // offscreen for bfcache) should not trigger fetches.\n        if (isActive) {\n            // Check if there's already a pending request.\n            let lazyData = cacheNode.lazyData;\n            if (lazyData === null) {\n                /**\n         * Router state with refetch marker added\n         */ // TODO-APP: remove ''\n                const refetchTree = walkAddRefetch([\n                    '',\n                    ...segmentPath\n                ], fullTree);\n                const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(fullTree);\n                const navigatedAt = Date.now();\n                cacheNode.lazyData = lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(url, location.origin), {\n                    flightRouterState: refetchTree,\n                    nextUrl: includeNextUrl ? // the next-url after a navigation, but we want the same\n                    // interception route to be matched that used the last\n                    // next-url.\n                    context.previousNextUrl || context.nextUrl : null\n                }).then((serverResponse)=>{\n                    (0, _react.startTransition)(()=>{\n                        (0, _useactionqueue.dispatchAppRouterAction)({\n                            type: _routerreducertypes.ACTION_SERVER_PATCH,\n                            previousTree: fullTree,\n                            serverResponse,\n                            navigatedAt\n                        });\n                    });\n                    return serverResponse;\n                });\n                // Suspend while waiting for lazyData to resolve\n                (0, _react.use)(lazyData);\n            }\n        }\n        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n        // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.\n        (0, _react.use)(_unresolvedthenable.unresolvedThenable);\n    }\n    // If we get to this point, then we know we have something we can render.\n    let content = resolvedRsc;\n    // In dev, we create a NavigationPromisesContext containing the instrumented promises that provide\n    // `useSelectedLayoutSegment` and `useSelectedLayoutSegments`.\n    // Promises are cached outside of render to survive suspense retries.\n    let navigationPromises = null;\n    if (true) {\n        const { createNestedLayoutNavigationPromises } = __webpack_require__(/*! ./navigation-devtools */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation-devtools.js\");\n        navigationPromises = createNestedLayoutNavigationPromises(tree, parentNavPromises);\n    }\n    if (navigationPromises) {\n        content = /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.NavigationPromisesContext.Provider, {\n            value: navigationPromises,\n            children: resolvedRsc\n        });\n    }\n    const subtree = /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {\n        value: {\n            parentTree: tree,\n            parentCacheNode: cacheNode,\n            parentSegmentPath: segmentPath,\n            parentParams: params,\n            debugNameContext: debugNameContext,\n            // TODO-APP: overriding of url for parallel routes\n            url: url,\n            isActive: isActive\n        },\n        children: content\n    });\n    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n    return subtree;\n}\n_c1 = InnerLayoutRouter;\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */ function LoadingBoundary({ name, loading, children }) {\n    // If loading is a promise, unwrap it. This happens in cases where we haven't\n    // yet received the loading data from the server — which includes whether or\n    // not this layout has a loading component at all.\n    //\n    // It's OK to suspend here instead of inside the fallback because this\n    // promise will resolve simultaneously with the data for the segment itself.\n    // So it will never suspend for longer than it would have if we didn't use\n    // a Suspense fallback at all.\n    let loadingModuleData;\n    if (typeof loading === 'object' && loading !== null && typeof loading.then === 'function') {\n        const promiseForLoading = loading;\n        loadingModuleData = (0, _react.use)(promiseForLoading);\n    } else {\n        loadingModuleData = loading;\n    }\n    if (loadingModuleData) {\n        const loadingRsc = loadingModuleData[0];\n        const loadingStyles = loadingModuleData[1];\n        const loadingScripts = loadingModuleData[2];\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {\n            name: name,\n            fallback: /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    loadingStyles,\n                    loadingScripts,\n                    loadingRsc\n                ]\n            }),\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c2 = LoadingBoundary;\nfunction OuterLayoutRouter({ parallelRouterKey, error, errorStyles, errorScripts, templateStyles, templateScripts, template, notFound, forbidden, unauthorized, segmentViewBoundaries }) {\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);\n    if (!context) {\n        throw Object.defineProperty(new Error('invariant expected layout router to be mounted'), \"__NEXT_ERROR_CODE\", {\n            value: \"E56\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const { parentTree, parentCacheNode, parentSegmentPath, parentParams, url, isActive, debugNameContext } = context;\n    // Get the CacheNode for this segment by reading it from the parent segment's\n    // child map.\n    const parentParallelRoutes = parentCacheNode.parallelRoutes;\n    let segmentMap = parentParallelRoutes.get(parallelRouterKey);\n    // If the parallel router cache node does not exist yet, create it.\n    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n    if (!segmentMap) {\n        segmentMap = new Map();\n        parentParallelRoutes.set(parallelRouterKey, segmentMap);\n    }\n    const parentTreeSegment = parentTree[0];\n    const segmentPath = parentSegmentPath === null ? // the code. We should clean this up.\n    [\n        parallelRouterKey\n    ] : parentSegmentPath.concat([\n        parentTreeSegment,\n        parallelRouterKey\n    ]);\n    // The \"state\" key of a segment is the one passed to React — it represents the\n    // identity of the UI tree. Whenever the state key changes, the tree is\n    // recreated and the state is reset. In the App Router model, search params do\n    // not cause state to be lost, so two segments with the same segment path but\n    // different search params should have the same state key.\n    //\n    // The \"cache\" key of a segment, however, *does* include the search params, if\n    // it's possible that the segment accessed the search params on the server.\n    // (This only applies to page segments; layout segments cannot access search\n    // params on the server.)\n    const activeTree = parentTree[1][parallelRouterKey];\n    const activeSegment = activeTree[0];\n    const activeStateKey = (0, _createroutercachekey.createRouterCacheKey)(activeSegment, true) // no search params\n    ;\n    // At each level of the route tree, not only do we render the currently\n    // active segment — we also render the last N segments that were active at\n    // this level inside a hidden <Activity> boundary, to preserve their state\n    // if or when the user navigates to them again.\n    //\n    // bfcacheEntry is a linked list of FlightRouterStates.\n    let bfcacheEntry = (0, _bfcache.useRouterBFCache)(activeTree, activeStateKey);\n    let children = [];\n    do {\n        const tree = bfcacheEntry.tree;\n        const stateKey = bfcacheEntry.stateKey;\n        const segment = tree[0];\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n        // Read segment path from the parallel router cache node.\n        let cacheNode = segmentMap.get(cacheKey);\n        if (cacheNode === undefined) {\n            // When data is not available during rendering client-side we need to fetch\n            // it from the server.\n            const newLazyCacheNode = {\n                lazyData: null,\n                rsc: null,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                parallelRoutes: new Map(),\n                loading: null,\n                navigatedAt: -1\n            };\n            // Flight data fetch kicked off during render and put into the cache.\n            cacheNode = newLazyCacheNode;\n            segmentMap.set(cacheKey, newLazyCacheNode);\n        }\n        /*\n    - Error boundary\n      - Only renders error boundary if error component is provided.\n      - Rendered for each segment to ensure they have their own error state.\n      - When gracefully degrade for bots, skip rendering error boundary.\n    - Loading boundary\n      - Only renders suspense boundary if loading components is provided.\n      - Rendered for each segment to ensure they have their own loading state.\n      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n  */ let segmentBoundaryTriggerNode = null;\n        let segmentViewStateNode = null;\n        if (true) {\n            const { SegmentBoundaryTriggerNode, SegmentViewStateNode } = __webpack_require__(/*! ../../next-devtools/userspace/app/segment-explorer-node */ \"(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js\");\n            const pagePrefix = (0, _apppaths.normalizeAppPath)(url);\n            segmentViewStateNode = /*#__PURE__*/ (0, _jsxruntime.jsx)(SegmentViewStateNode, {\n                page: pagePrefix\n            }, pagePrefix);\n            segmentBoundaryTriggerNode = /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(SegmentBoundaryTriggerNode, {})\n            });\n        }\n        let params = parentParams;\n        if (Array.isArray(segment)) {\n            // This segment contains a route param. Accumulate these as we traverse\n            // down the router tree. The result represents the set of params that\n            // the layout/page components are permitted to access below this point.\n            const paramName = segment[0];\n            const paramCacheKey = segment[1];\n            const paramType = segment[2];\n            const paramValue = (0, _routeparams.getParamValueFromCacheKey)(paramCacheKey, paramType);\n            if (paramValue !== null) {\n                params = {\n                    ...parentParams,\n                    [paramName]: paramValue\n                };\n            }\n        }\n        const debugName = getBoundaryDebugNameFromSegment(segment);\n        // `debugNameContext` represents the nearest non-\"virtual\" parent segment.\n        // `getBoundaryDebugNameFromSegment` returns undefined for virtual segments.\n        // So if `debugName` is undefined, the context is passed through unchanged.\n        const childDebugNameContext = debugName ?? debugNameContext;\n        // In practical terms, clicking this name in the Suspense DevTools\n        // should select the child slots of that layout.\n        //\n        // So the name we apply to the Activity boundary is actually based on\n        // the nearest parent segments.\n        //\n        // We skip over \"virtual\" parents, i.e. ones inserted by Next.js that\n        // don't correspond to application-defined code.\n        const isVirtual = debugName === undefined;\n        const debugNameToDisplay = isVirtual ? undefined : debugNameContext;\n        // TODO: The loading module data for a segment is stored on the parent, then\n        // applied to each of that parent segment's parallel route slots. In the\n        // simple case where there's only one parallel route (the `children` slot),\n        // this is no different from if the loading module data where stored on the\n        // child directly. But I'm not sure this actually makes sense when there are\n        // multiple parallel routes. It's not a huge issue because you always have\n        // the option to define a narrower loading boundary for a particular slot. But\n        // this sort of smells like an implementation accident to me.\n        const loadingModuleData = parentCacheNode.loading;\n        let child = /*#__PURE__*/ (0, _jsxruntime.jsxs)(_approutercontextsharedruntime.TemplateContext.Provider, {\n            value: /*#__PURE__*/ (0, _jsxruntime.jsxs)(ScrollAndFocusHandler, {\n                segmentPath: segmentPath,\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary.ErrorBoundary, {\n                        errorComponent: error,\n                        errorStyles: errorStyles,\n                        errorScripts: errorScripts,\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(LoadingBoundary, {\n                            name: debugNameToDisplay,\n                            loading: loadingModuleData,\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary1.HTTPAccessFallbackBoundary, {\n                                notFound: notFound,\n                                forbidden: forbidden,\n                                unauthorized: unauthorized,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsxs)(_redirectboundary.RedirectBoundary, {\n                                    children: [\n                                        /*#__PURE__*/ (0, _jsxruntime.jsx)(InnerLayoutRouter, {\n                                            url: url,\n                                            tree: tree,\n                                            params: params,\n                                            cacheNode: cacheNode,\n                                            segmentPath: segmentPath,\n                                            debugNameContext: childDebugNameContext,\n                                            isActive: isActive && stateKey === activeStateKey\n                                        }),\n                                        segmentBoundaryTriggerNode\n                                    ]\n                                })\n                            })\n                        })\n                    }),\n                    segmentViewStateNode\n                ]\n            }),\n            children: [\n                templateStyles,\n                templateScripts,\n                template\n            ]\n        }, stateKey);\n        if (true) {\n            const { SegmentStateProvider } = __webpack_require__(/*! ../../next-devtools/userspace/app/segment-explorer-node */ \"(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js\");\n            child = /*#__PURE__*/ (0, _jsxruntime.jsxs)(SegmentStateProvider, {\n                children: [\n                    child,\n                    segmentViewBoundaries\n                ]\n            }, stateKey);\n        }\n        if (false) {}\n        children.push(child);\n        bfcacheEntry = bfcacheEntry.next;\n    }while (bfcacheEntry !== null);\n    return children;\n}\n_c3 = OuterLayoutRouter;\nfunction getBoundaryDebugNameFromSegment(segment) {\n    if (segment === '/') {\n        // Reached the root\n        return '/';\n    }\n    if (typeof segment === 'string') {\n        if (isVirtualLayout(segment)) {\n            return undefined;\n        } else {\n            return segment + '/';\n        }\n    }\n    const paramCacheKey = segment[1];\n    return paramCacheKey + '/';\n}\nfunction isVirtualLayout(segment) {\n    return(// in a more special way instead of checking the name, to distinguish them\n    // from app-defined groups.\n    segment === '(slot)');\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=layout-router.js.map\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"ScrollAndFocusHandler\");\n$RefreshReg$(_c1, \"InnerLayoutRouter\");\n$RefreshReg$(_c2, \"LoadingBoundary\");\n$RefreshReg$(_c3, \"OuterLayoutRouter\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbGF5b3V0LXJvdXRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OzJDQThoQkE7OztlQUF3QkE7Ozs7OztnREE5Z0JqQjs2RUFXQTsrRUFDYzsyREFLZDtpREFDNkI7Z0RBQ0Q7MkNBQ0w7MkNBQ0Q7aURBQzRCOzhDQUN4Qjs0Q0FDVTtrREFDTjsrREFDYTs0Q0FDVjtxQ0FDa0I7c0NBQ3pCOzZEQUkxQjt5Q0FDbUM7QUFHMUM7OztDQUdDLEdBQ0QsU0FBU0MsZUFDUEMsaUJBQWdELEVBQ2hEQyxjQUFpQztJQUVqQyxJQUFJRCxtQkFBbUI7UUFDckIsTUFBTSxDQUFDRSxTQUFTQyxpQkFBaUIsR0FBR0g7UUFDcEMsTUFBTUksU0FBU0osa0JBQWtCSyxNQUFNLEtBQUs7UUFFNUMsSUFBSUMsQ0FBQUEsR0FBQUEsZUFBQUEsWUFBQUEsRUFBYUwsY0FBYyxDQUFDLEVBQUUsRUFBRUMsVUFBVTtZQUM1QyxJQUFJRCxjQUFjLENBQUMsRUFBRSxDQUFDTSxjQUFjLENBQUNKLG1CQUFtQjtnQkFDdEQsSUFBSUMsUUFBUTtvQkFDVixNQUFNSSxVQUFVVCxlQUNkVSxXQUNBUixjQUFjLENBQUMsRUFBRSxDQUFDRSxpQkFBaUI7b0JBRXJDLE9BQU87d0JBQ0xGLGNBQWMsQ0FBQyxFQUFFO3dCQUNqQjs0QkFDRSxHQUFHQSxjQUFjLENBQUMsRUFBRTs0QkFDcEIsQ0FBQ0UsaUJBQWlCLEVBQUU7Z0NBQ2xCSyxPQUFPLENBQUMsRUFBRTtnQ0FDVkEsT0FBTyxDQUFDLEVBQUU7Z0NBQ1ZBLE9BQU8sQ0FBQyxFQUFFO2dDQUNWOzZCQUNEO3dCQUNIO3FCQUNEO2dCQUNIO2dCQUVBLE9BQU87b0JBQ0xQLGNBQWMsQ0FBQyxFQUFFO29CQUNqQjt3QkFDRSxHQUFHQSxjQUFjLENBQUMsRUFBRTt3QkFDcEIsQ0FBQ0UsaUJBQWlCLEVBQUVKLGVBQ2xCQyxrQkFBa0JVLEtBQUssQ0FB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QTswQ0FFZCxvQ0FBQzZDLGtCQUFBQSxnQkFBZ0I7O3NEQUNmLHFCQUFDbEgsbUJBQUFBOzRDQUNDSyxLQUFLQTs0Q0FDTEosTUFBTUE7NENBQ05HLFFBQVFBOzRDQUNSRCxXQUFXQTs0Q0FDWC9CLGFBQWFBOzRDQUNiOEIsa0JBQWtCd0c7NENBQ2xCcEcsVUFBVUEsWUFBWStFLGFBQWFKOzt3Q0FFcENTOzs7Ozs7b0JBS1JDOzs7O2dCQUlKM0I7Z0JBQ0FDO2dCQUNBQzs7V0F0Q0ltQjtRQTBDVCxJQUFJekcsSUFBb0IsRUFBbUI7WUFDekMsTUFBTSxFQUFFdUksb0JBQW9CLEVBQUUsR0FDNUIxRSxtQkFBT0EsQ0FBQyxrS0FBeUQ7WUFFbkVvRSxRQUNFLFdBREZBLEdBQ0Usc0JBQUNNLHNCQUFBQTs7b0JBQ0VOO29CQUNBdkM7O2VBRndCZTtRQUsvQjtRQUVBLElBQUl6RyxLQUFtQyxFQUFFLEVBVXhDO1FBRURULFNBQVNvSixJQUFJLENBQUNWO1FBRWQxQixlQUFlQSxhQUFhcUMsSUFBSTtJQUNsQyxRQUFTckMsaUJBQWlCLE1BQUs7SUFFL0IsT0FBT2hIO0FBQ1Q7O0FBRUEsU0FBU3NJLGdDQUFnQ2xMLE9BQWdCO0lBQ3ZELElBQUlBLFlBQVksS0FBSztRQUNuQixtQkFBbUI7UUFDbkIsT0FBTztJQUNUO0lBQ0EsSUFBSSxPQUFPQSxZQUFZLFVBQVU7UUFDL0IsSUFBSWtNLGdCQUFnQmxNLFVBQVU7WUFDNUIsT0FBT087UUFDVCxPQUFPO1lBQ0wsT0FBT1AsVUFBVTtRQUNuQjtJQUNGO0lBQ0EsTUFBTTZLLGdCQUFnQjdLLE9BQU8sQ0FBQyxFQUFFO0lBQ2hDLE9BQU82SyxnQkFBZ0I7QUFDekI7QUFFQSxTQUFTcUIsZ0JBQWdCbE0sT0FBZTtJQUN0QyxPQUNFLG9FQUFvRSxNQUNNO0lBQzFFLDJCQUEyQjtJQUMzQkEsWUFBWTtBQUVoQiIsInNvdXJjZXMiOlsiL3NyYy9jbGllbnQvY29tcG9uZW50cy9sYXlvdXQtcm91dGVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHR5cGUge1xuICBDYWNoZU5vZGUsXG4gIExhenlDYWNoZU5vZGUsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci10eXBlcydcbmltcG9ydCB0eXBlIHsgTG9hZGluZ01vZHVsZURhdGEgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItdHlwZXMnXG5pbXBvcnQgdHlwZSB7XG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBGbGlnaHRTZWdtZW50UGF0aCxcbiAgU2VnbWVudCxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLXR5cGVzJ1xuaW1wb3J0IHR5cGUgeyBFcnJvckNvbXBvbmVudCB9IGZyb20gJy4vZXJyb3ItYm91bmRhcnknXG5pbXBvcnQge1xuICBBQ1RJT05fU0VSVkVSX1BBVENILFxuICB0eXBlIEZvY3VzQW5kU2Nyb2xsUmVmLFxufSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuXG5pbXBvcnQgUmVhY3QsIHtcbiAgQWN0aXZpdHksXG4gIHVzZUNvbnRleHQsXG4gIHVzZSxcbiAgc3RhcnRUcmFuc2l0aW9uLFxuICBTdXNwZW5zZSxcbiAgdXNlRGVmZXJyZWRWYWx1ZSxcbiAgdHlwZSBKU1gsXG4gIHR5cGUgQWN0aXZpdHlQcm9wcyxcbn0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJ1xuaW1wb3J0IHtcbiAgTGF5b3V0Um91dGVyQ29udGV4dCxcbiAgR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCxcbiAgVGVtcGxhdGVDb250ZXh0LFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGZldGNoU2VydmVyUmVzcG9uc2UgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL2ZldGNoLXNlcnZlci1yZXNwb25zZSdcbmltcG9ydCB7IHVucmVzb2x2ZWRUaGVuYWJsZSB9IGZyb20gJy4vdW5yZXNvbHZlZC10aGVuYWJsZSdcbmltcG9ydCB7IEVycm9yQm91bmRhcnkgfSBmcm9tICcuL2Vycm9yLWJvdW5kYXJ5J1xuaW1wb3J0IHsgbWF0Y2hTZWdtZW50IH0gZnJvbSAnLi9tYXRjaC1zZWdtZW50cydcbmltcG9ydCB7IGRpc2FibGVTbW9vdGhTY3JvbGxEdXJpbmdSb3V0ZVRyYW5zaXRpb24gfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9kaXNhYmxlLXNtb290aC1zY3JvbGwnXG5pbXBvcnQgeyBSZWRpcmVjdEJvdW5kYXJ5IH0gZnJvbSAnLi9yZWRpcmVjdC1ib3VuZGFyeSdcbmltcG9ydCB7IEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5IH0gZnJvbSAnLi9odHRwLWFjY2Vzcy1mYWxsYmFjay9lcnJvci1ib3VuZGFyeSdcbmltcG9ydCB7IGNyZWF0ZVJvdXRlckNhY2hlS2V5IH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9jcmVhdGUtcm91dGVyLWNhY2hlLWtleSdcbmltcG9ydCB7IGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvaGFzLWludGVyY2VwdGlvbi1yb3V0ZS1pbi1jdXJyZW50LXRyZWUnXG5pbXBvcnQgeyBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbiB9IGZyb20gJy4vdXNlLWFjdGlvbi1xdWV1ZSdcbmltcG9ydCB7IHVzZVJvdXRlckJGQ2FjaGUsIHR5cGUgUm91dGVyQkZDYWNoZUVudHJ5IH0gZnJvbSAnLi9iZmNhY2hlJ1xuaW1wb3J0IHsgbm9ybWFsaXplQXBwUGF0aCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FwcC1wYXRocydcbmltcG9ydCB7XG4gIE5hdmlnYXRpb25Qcm9taXNlc0NvbnRleHQsXG4gIHR5cGUgTmF2aWdhdGlvblByb21pc2VzLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2hvb2tzLWNsaWVudC1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgZ2V0UGFyYW1WYWx1ZUZyb21DYWNoZUtleSB9IGZyb20gJy4uL3JvdXRlLXBhcmFtcydcbmltcG9ydCB0eXBlIHsgUGFyYW1zIH0gZnJvbSAnLi4vLi4vc2VydmVyL3JlcXVlc3QvcGFyYW1zJ1xuXG4vKipcbiAqIEFkZCByZWZldGNoIG1hcmtlciB0byByb3V0ZXIgc3RhdGUgYXQgdGhlIHBvaW50IG9mIHRoZSBjdXJyZW50IGxheW91dCBzZWdtZW50LlxuICogVGhpcyBlbnN1cmVzIHRoZSByZXNwb25zZSByZXR1cm5lZCBpcyBub3QgZnVydGhlciBkb3duIHRoYW4gdGhlIGN1cnJlbnQgbGF5b3V0IHNlZ21lbnQuXG4gKi9cbmZ1bmN0aW9uIHdhbGtBZGRSZWZldGNoKFxuICBzZWdtZW50UGF0aFRvV2FsazogRmxpZ2h0U2VnbWVudFBhdGggfCB1bmRlZmluZWQsXG4gIHRyZWVUb1JlY3JlYXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuKTogRmxpZ2h0Um91dGVyU3RhdGUge1xuICBpZiAoc2VnbWVudFBhdGhUb1dhbGspIHtcbiAgICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZUtleV0gPSBzZWdtZW50UGF0aFRvV2Fsa1xuICAgIGNvbnN0IGlzTGFzdCA9IHNlZ21lbnRQYXRoVG9XYWxrLmxlbmd0aCA9PT0gMlxuXG4gICAgaWYgKG1hdGNoU2VnbWVudCh0cmVlVG9SZWNyZWF0ZVswXSwgc2VnbWVudCkpIHtcbiAgICAgIGlmICh0cmVlVG9SZWNyZWF0ZVsxXS5oYXNPd25Qcm9wZXJ0eShwYXJhbGxlbFJvdXRlS2V5KSkge1xuICAgICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IHdhbGtBZGRSZWZldGNoKFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHJlZVRvUmVjcmVhdGVbMV1bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRyZWVUb1JlY3JlYXRlWzBdLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi50cmVlVG9SZWNyZWF0ZVsxXSxcbiAgICAgICAgICAgICAgW3BhcmFsbGVsUm91dGVLZXldOiBbXG4gICAgICAgICAgICAgICAgc3ViVHJlZVswXSxcbiAgICAgICAgICAgICAgICBzdWJUcmVlWzFdLFxuICAgICAgICAgICAgICAgIHN1YlRyZWVbMl0sXG4gICAgICAgICAgICAgICAgJ3JlZmV0Y2gnLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHRyZWVUb1JlY3JlYXRlWzBdLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLnRyZWVUb1JlY3JlYXRlWzFdLFxuICAgICAgICAgICAgW3BhcmFsbGVsUm91dGVLZXldOiB3YWxrQWRkUmVmZXRjaChcbiAgICAgICAgICAgICAgc2VnbWVudFBhdGhUb1dhbGsuc2xpY2UoMiksXG4gICAgICAgICAgICAgIHRyZWVUb1JlY3JlYXRlWzFdW3BhcmFsbGVsUm91dGVLZXldXG4gICAgICAgICAgICApLFxuICAgICAgICAgIH0sXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJlZVRvUmVjcmVhdGVcbn1cblxuY29uc3QgX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFID0gKFxuICBSZWFjdERPTSBhcyBhbnlcbikuX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFXG5cbi8vIFRPRE8tQVBQOiBSZXBsYWNlIHdpdGggbmV3IFJlYWN0IEFQSSBmb3IgZmluZGluZyBkb20gbm9kZXMgd2l0aG91dCBhIGByZWZgIHdoZW4gYXZhaWxhYmxlXG4vKipcbiAqIFdyYXBzIFJlYWN0RE9NLmZpbmRET01Ob2RlIHdpdGggYWRkaXRpb25hbCBsb2dpYyB0byBoaWRlIFJlYWN0IFN0cmljdCBNb2RlIHdhcm5pbmdcbiAqL1xuZnVuY3Rpb24gZmluZERPTU5vZGUoXG4gIGluc3RhbmNlOiBSZWFjdC5SZWFjdEluc3RhbmNlIHwgbnVsbCB8IHVuZGVmaW5lZFxuKTogRWxlbWVudCB8IFRleHQgfCBudWxsIHtcbiAgLy8gVHJlZS1zaGFrZSBmb3Igc2VydmVyIGJ1bmRsZVxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBudWxsXG5cbiAgLy8gX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLmZpbmRET01Ob2RlIGlzIG51bGwgZHVyaW5nIG1vZHVsZSBpbml0LlxuICAvLyBXZSBuZWVkIHRvIGxhemlseSByZWZlcmVuY2UgaXQuXG4gIGNvbnN0IGludGVybmFsX3JlYWN0RE9NZmluZERPTU5vZGUgPVxuICAgIF9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERS5maW5kRE9NTm9kZVxuICByZXR1cm4gaW50ZXJuYWxfcmVhY3RET01maW5kRE9NTm9kZShpbnN0YW5jZSlcbn1cblxuY29uc3QgcmVjdFByb3BlcnRpZXMgPSBbXG4gICdib3R0b20nLFxuICAnaGVpZ2h0JyxcbiAgJ2xlZnQnLFxuICAncmlnaHQnLFxuICAndG9wJyxcbiAgJ3dpZHRoJyxcbiAgJ3gnLFxuICAneScsXG5dIGFzIGNvbnN0XG4vKipcbiAqIENoZWNrIGlmIGEgSFRNTEVsZW1lbnQgaXMgaGlkZGVuIG9yIGZpeGVkL3N0aWNreSBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBzaG91bGRTa2lwRWxlbWVudChlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAvLyB3ZSBpZ25vcmUgZml4ZWQgb3Igc3RpY2t5IHBvc2l0aW9uZWQgZWxlbWVudHMgc2luY2UgdGhleSdsbCBsaWtlbHkgcGFzcyB0aGUgXCJpbi12aWV3cG9ydFwiIGNoZWNrXG4gIC8vIGFuZCB3aWxsIHJlc3VsdCBpbiBhIHNpdHVhdGlvbiB3ZSBiYWlsIG9uIHNjcm9sbCBiZWNhdXNlIG9mIHNvbWV0aGluZyBsaWtlIGEgZml4ZWQgbmF2LFxuICAvLyBldmVuIHRob3VnaCB0aGUgYWN0dWFsIHBhZ2UgY29udGVudCBpcyBvZmZzY3JlZW5cbiAgaWYgKFsnc3RpY2t5JywgJ2ZpeGVkJ10uaW5jbHVkZXMoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gVXNlcyBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCB0byBjaGVjayBpZiB0aGUgZWxlbWVudCBpcyBoaWRkZW4gaW5zdGVhZCBvZiBgb2Zmc2V0UGFyZW50YFxuICAvLyBiZWNhdXNlIGBvZmZzZXRQYXJlbnRgIGRvZXNuJ3QgY29uc2lkZXIgZG9jdW1lbnQvYm9keVxuICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICByZXR1cm4gcmVjdFByb3BlcnRpZXMuZXZlcnkoKGl0ZW0pID0+IHJlY3RbaXRlbV0gPT09IDApXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHRvcCBjb3JuZXIgb2YgdGhlIEhUTUxFbGVtZW50IGlzIGluIHRoZSB2aWV3cG9ydC5cbiAqL1xuZnVuY3Rpb24gdG9wT2ZFbGVtZW50SW5WaWV3cG9ydChlbGVtZW50OiBIVE1MRWxlbWVudCwgdmlld3BvcnRIZWlnaHQ6IG51bWJlcikge1xuICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICByZXR1cm4gcmVjdC50b3AgPj0gMCAmJiByZWN0LnRvcCA8PSB2aWV3cG9ydEhlaWdodFxufVxuXG4vKipcbiAqIEZpbmQgdGhlIERPTSBub2RlIGZvciBhIGhhc2ggZnJhZ21lbnQuXG4gKiBJZiBgdG9wYCB0aGUgcGFnZSBoYXMgdG8gc2Nyb2xsIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UuIFRoaXMgbWlycm9ycyB0aGUgYnJvd3NlcidzIGJlaGF2aW9yLlxuICogSWYgdGhlIGhhc2ggZnJhZ21lbnQgaXMgYW4gaWQsIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIGVsZW1lbnQgd2l0aCB0aGF0IGlkLlxuICogSWYgdGhlIGhhc2ggZnJhZ21lbnQgaXMgYSBuYW1lLCB0aGUgcGFnZSBoYXMgdG8gc2Nyb2xsIHRvIHRoZSBmaXJzdCBlbGVtZW50IHdpdGggdGhhdCBuYW1lLlxuICovXG5mdW5jdGlvbiBnZXRIYXNoRnJhZ21lbnREb21Ob2RlKGhhc2hGcmFnbWVudDogc3RyaW5nKSB7XG4gIC8vIElmIHRoZSBoYXNoIGZyYWdtZW50IGlzIGB0b3BgIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZS5cbiAgaWYgKGhhc2hGcmFnbWVudCA9PT0gJ3RvcCcpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keVxuICB9XG5cbiAgLy8gSWYgdGhlIGhhc2ggZnJhZ21lbnQgaXMgYW4gaWQsIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIGVsZW1lbnQgd2l0aCB0aGF0IGlkLlxuICByZXR1cm4gKFxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2hGcmFnbWVudCkgPz9cbiAgICAvLyBJZiB0aGUgaGFzaCBmcmFnbWVudCBpcyBhIG5hbWUsIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIGZpcnN0IGVsZW1lbnQgd2l0aCB0aGF0IG5hbWUuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoaGFzaEZyYWdtZW50KVswXVxuICApXG59XG5pbnRlcmZhY2UgU2Nyb2xsQW5kRm9jdXNIYW5kbGVyUHJvcHMge1xuICBmb2N1c0FuZFNjcm9sbFJlZjogRm9jdXNBbmRTY3JvbGxSZWZcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxuICBzZWdtZW50UGF0aDogRmxpZ2h0U2VnbWVudFBhdGhcbn1cbmNsYXNzIElubmVyU2Nyb2xsQW5kRm9jdXNIYW5kbGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFNjcm9sbEFuZEZvY3VzSGFuZGxlclByb3BzPiB7XG4gIGhhbmRsZVBvdGVudGlhbFNjcm9sbCA9ICgpID0+IHtcbiAgICAvLyBIYW5kbGUgc2Nyb2xsIGFuZCBmb2N1cywgaXQncyBvbmx5IGFwcGxpZWQgb25jZSBpbiB0aGUgZmlyc3QgdXNlRWZmZWN0IHRoYXQgdHJpZ2dlcnMgdGhhdCBjaGFuZ2VkLlxuICAgIGNvbnN0IHsgZm9jdXNBbmRTY3JvbGxSZWYsIHNlZ21lbnRQYXRoIH0gPSB0aGlzLnByb3BzXG5cbiAgICBpZiAoZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkpIHtcbiAgICAgIC8vIHNlZ21lbnRQYXRocyBpcyBhbiBhcnJheSBvZiBzZWdtZW50IHBhdGhzIHRoYXQgc2hvdWxkIGJlIHNjcm9sbGVkIHRvXG4gICAgICAvLyBpZiB0aGUgY3VycmVudCBzZWdtZW50IHBhdGggaXMgbm90IGluIHRoZSBhcnJheSwgdGhlIHNjcm9sbCBpcyBub3QgYXBwbGllZFxuICAgICAgLy8gdW5sZXNzIHRoZSBhcnJheSBpcyBlbXB0eSwgaW4gd2hpY2ggY2FzZSB0aGUgc2Nyb2xsIGlzIGFsd2F5cyBhcHBsaWVkXG4gICAgICBpZiAoXG4gICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLnNlZ21lbnRQYXRocy5sZW5ndGggIT09IDAgJiZcbiAgICAgICAgIWZvY3VzQW5kU2Nyb2xsUmVmLnNlZ21lbnRQYXRocy5zb21lKChzY3JvbGxSZWZTZWdtZW50UGF0aCkgPT5cbiAgICAgICAgICBzZWdtZW50UGF0aC5ldmVyeSgoc2VnbWVudCwgaW5kZXgpID0+XG4gICAgICAgICAgICBtYXRjaFNlZ21lbnQoc2VnbWVudCwgc2Nyb2xsUmVmU2VnbWVudFBhdGhbaW5kZXhdKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBsZXQgZG9tTm9kZTpcbiAgICAgICAgfCBSZXR1cm5UeXBlPHR5cGVvZiBnZXRIYXNoRnJhZ21lbnREb21Ob2RlPlxuICAgICAgICB8IFJldHVyblR5cGU8dHlwZW9mIGZpbmRET01Ob2RlPiA9IG51bGxcbiAgICAgIGNvbnN0IGhhc2hGcmFnbWVudCA9IGZvY3VzQW5kU2Nyb2xsUmVmLmhhc2hGcmFnbWVudFxuXG4gICAgICBpZiAoaGFzaEZyYWdtZW50KSB7XG4gICAgICAgIGRvbU5vZGUgPSBnZXRIYXNoRnJhZ21lbnREb21Ob2RlKGhhc2hGcmFnbWVudClcbiAgICAgIH1cblxuICAgICAgLy8gYGZpbmRET01Ob2RlYCBpcyB0cmlja3kgYmVjYXVzZSBpdCByZXR1cm5zIGp1c3QgdGhlIGZpcnN0IGNoaWxkIGlmIHRoZSBjb21wb25lbnQgaXMgYSBmcmFnbWVudC5cbiAgICAgIC8vIFRoaXMgYWxyZWFkeSBjYXVzZWQgYSBidWcgd2hlcmUgdGhlIGZpcnN0IGNoaWxkIHdhcyBhIDxsaW5rLz4gaW4gaGVhZC5cbiAgICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgICBkb21Ob2RlID0gZmluZERPTU5vZGUodGhpcylcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gRE9NIG5vZGUgdGhpcyBsYXlvdXQtcm91dGVyIGxldmVsIGlzIHNraXBwZWQuIEl0J2xsIGJlIGhhbmRsZWQgaGlnaGVyLXVwIGluIHRoZSB0cmVlLlxuICAgICAgaWYgKCEoZG9tTm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBWZXJpZnkgaWYgdGhlIGVsZW1lbnQgaXMgYSBIVE1MRWxlbWVudCBhbmQgaWYgd2Ugd2FudCB0byBjb25zaWRlciBpdCBmb3Igc2Nyb2xsIGJlaGF2aW9yLlxuICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgc2tpcHBlZCwgdHJ5IHRvIHNlbGVjdCB0aGUgbmV4dCBzaWJsaW5nIGFuZCB0cnkgYWdhaW4uXG4gICAgICB3aGlsZSAoIShkb21Ob2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHx8IHNob3VsZFNraXBFbGVtZW50KGRvbU5vZGUpKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGRvbU5vZGUucGFyZW50RWxlbWVudD8ubG9jYWxOYW1lID09PSAnaGVhZCcpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFdlIGVudGVyIHRoaXMgc3RhdGUgd2hlbiBtZXRhZGF0YSB3YXMgcmVuZGVyZWQgYXMgcGFydCBvZiB0aGUgcGFnZSBvciB2aWEgTmV4dC5qcy5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYWx3YXlzIGEgYnVnIGluIE5leHQuanMgYW5kIGNhdXNlZCBieSBSZWFjdCBob2lzdGluZyBtZXRhZGF0YS5cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcmVwbGFjZSBgZmluZERPTU5vZGVgIGluIGZhdm9yIG9mIEZyYWdtZW50IFJlZnMgKHdoZW4gYXZhaWxhYmxlKSBzbyB0aGF0IHdlIGNhbiBza2lwIG92ZXIgbWV0YWRhdGEuXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm8gc2libGluZ3MgZm91bmQgdGhhdCBtYXRjaCB0aGUgY3JpdGVyaWEgYXJlIGZvdW5kLCBzbyBoYW5kbGUgc2Nyb2xsIGhpZ2hlciB1cCBpbiB0aGUgdHJlZSBpbnN0ZWFkLlxuICAgICAgICBpZiAoZG9tTm9kZS5uZXh0RWxlbWVudFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBkb21Ob2RlID0gZG9tTm9kZS5uZXh0RWxlbWVudFNpYmxpbmdcbiAgICAgIH1cblxuICAgICAgLy8gU3RhdGUgaXMgbXV0YXRlZCB0byBlbnN1cmUgdGhhdCB0aGUgZm9jdXMgYW5kIHNjcm9sbCBpcyBhcHBsaWVkIG9ubHkgb25jZS5cbiAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLmFwcGx5ID0gZmFsc2VcbiAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLmhhc2hGcmFnbWVudCA9IG51bGxcbiAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLnNlZ21lbnRQYXRocyA9IFtdXG5cbiAgICAgIGRpc2FibGVTbW9vdGhTY3JvbGxEdXJpbmdSb3V0ZVRyYW5zaXRpb24oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAvLyBJbiBjYXNlIG9mIGhhc2ggc2Nyb2xsLCB3ZSBvbmx5IG5lZWQgdG8gc2Nyb2xsIHRoZSBlbGVtZW50IGludG8gdmlld1xuICAgICAgICAgIGlmIChoYXNoRnJhZ21lbnQpIHtcbiAgICAgICAgICAgIDsoZG9tTm9kZSBhcyBIVE1MRWxlbWVudCkuc2Nyb2xsSW50b1ZpZXcoKVxuXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgdmlld3BvcnQgaGVpZ2h0IGJlY2F1c2UgcmVhZGluZyBgY2xpZW50SGVpZ2h0YCBjYXVzZXMgYSByZWZsb3csXG4gICAgICAgICAgLy8gYW5kIGl0IHdvbid0IGNoYW5nZSBkdXJpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgICAgICBjb25zdCBodG1sRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuICAgICAgICAgIGNvbnN0IHZpZXdwb3J0SGVpZ2h0ID0gaHRtbEVsZW1lbnQuY2xpZW50SGVpZ2h0XG5cbiAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCdzIHRvcCBlZGdlIGlzIGFscmVhZHkgaW4gdGhlIHZpZXdwb3J0LCBleGl0IGVhcmx5LlxuICAgICAgICAgIGlmICh0b3BPZkVsZW1lbnRJblZpZXdwb3J0KGRvbU5vZGUgYXMgSFRNTEVsZW1lbnQsIHZpZXdwb3J0SGVpZ2h0KSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0cnkgc2Nyb2xsaW5nIGdvIHRoZSB0b3Agb2YgdGhlIGRvY3VtZW50IHRvIGJlIGJhY2t3YXJkIGNvbXBhdGlibGUgd2l0aCBwYWdlc1xuICAgICAgICAgIC8vIHNjcm9sbEludG9WaWV3KCkgY2FsbGVkIG9uIGA8aHRtbC8+YCBlbGVtZW50IHNjcm9sbHMgaG9yaXpvbnRhbGx5IG9uIGNocm9tZSBhbmQgZmlyZWZveCAodGhhdCBzaG91bGRuJ3QgaGFwcGVuKVxuICAgICAgICAgIC8vIFdlIGNvdWxkIHVzZSBpdCB0byBzY3JvbGwgaG9yaXpvbnRhbGx5IGZvbGxvd2luZyBSVEwgYnV0IHRoYXQgYWxzbyBzZWVtcyB0byBiZSBicm9rZW4gLSBpdCB3aWxsIGFsd2F5cyBzY3JvbGwgbGVmdFxuICAgICAgICAgIC8vIHNjcm9sbExlZnQgPSAwIGFsc28gc2VlbXMgdG8gaWdub3JlIFJUTCBhbmQgbWFudWFsbHkgY2hlY2tpbmcgZm9yIFJUTCBpcyB0b28gbXVjaCBoYXNzbGUgc28gd2Ugd2lsbCBzY3JvbGwganVzdCB2ZXJ0aWNhbGx5XG4gICAgICAgICAgaHRtbEVsZW1lbnQuc2Nyb2xsVG9wID0gMFxuXG4gICAgICAgICAgLy8gU2Nyb2xsIHRvIGRvbU5vZGUgaWYgZG9tTm9kZSBpcyBub3QgaW4gdmlld3BvcnQgd2hlbiBzY3JvbGxlZCB0byB0b3Agb2YgZG9jdW1lbnRcbiAgICAgICAgICBpZiAoIXRvcE9mRWxlbWVudEluVmlld3BvcnQoZG9tTm9kZSBhcyBIVE1MRWxlbWVudCwgdmlld3BvcnRIZWlnaHQpKSB7XG4gICAgICAgICAgICAvLyBTY3JvbGwgaW50byB2aWV3IGRvZXNuJ3Qgc2Nyb2xsIGhvcml6b250YWxseSBieSBkZWZhdWx0IHdoZW4gbm90IG5lZWRlZFxuICAgICAgICAgICAgOyhkb21Ob2RlIGFzIEhUTUxFbGVtZW50KS5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2Ugd2lsbCBmb3JjZSBsYXlvdXQgYnkgcXVlcnlpbmcgZG9tTm9kZSBwb3NpdGlvblxuICAgICAgICAgIGRvbnRGb3JjZUxheW91dDogdHJ1ZSxcbiAgICAgICAgICBvbmx5SGFzaENoYW5nZTogZm9jdXNBbmRTY3JvbGxSZWYub25seUhhc2hDaGFuZ2UsXG4gICAgICAgIH1cbiAgICAgIClcblxuICAgICAgLy8gTXV0YXRlIGFmdGVyIHNjcm9sbGluZyBzbyB0aGF0IGl0IGNhbiBiZSByZWFkIGJ5IGBkaXNhYmxlU21vb3RoU2Nyb2xsRHVyaW5nUm91dGVUcmFuc2l0aW9uYFxuICAgICAgZm9jdXNBbmRTY3JvbGxSZWYub25seUhhc2hDaGFuZ2UgPSBmYWxzZVxuXG4gICAgICAvLyBTZXQgZm9jdXMgb24gdGhlIGVsZW1lbnRcbiAgICAgIGRvbU5vZGUuZm9jdXMoKVxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuaGFuZGxlUG90ZW50aWFsU2Nyb2xsKClcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAvLyBCZWNhdXNlIHRoaXMgcHJvcGVydHkgaXMgb3ZlcndyaXR0ZW4gaW4gaGFuZGxlUG90ZW50aWFsU2Nyb2xsIGl0J3MgZmluZSB0byBhbHdheXMgcnVuIGl0IHdoZW4gdHJ1ZSBhcyBpdCdsbCBiZSBzZXQgdG8gZmFsc2UgZm9yIHN1YnNlcXVlbnQgcmVuZGVycy5cbiAgICBpZiAodGhpcy5wcm9wcy5mb2N1c0FuZFNjcm9sbFJlZi5hcHBseSkge1xuICAgICAgdGhpcy5oYW5kbGVQb3RlbnRpYWxTY3JvbGwoKVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlblxuICB9XG59XG5cbmZ1bmN0aW9uIFNjcm9sbEFuZEZvY3VzSGFuZGxlcih7XG4gIHNlZ21lbnRQYXRoLFxuICBjaGlsZHJlbixcbn06IHtcbiAgc2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoXG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcbn0pIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dClcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgZ2xvYmFsIGxheW91dCByb3V0ZXIgbm90IG1vdW50ZWQnKVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8SW5uZXJTY3JvbGxBbmRGb2N1c0hhbmRsZXJcbiAgICAgIHNlZ21lbnRQYXRoPXtzZWdtZW50UGF0aH1cbiAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmPXtjb250ZXh0LmZvY3VzQW5kU2Nyb2xsUmVmfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0lubmVyU2Nyb2xsQW5kRm9jdXNIYW5kbGVyPlxuICApXG59XG5cbi8qKlxuICogSW5uZXJMYXlvdXRSb3V0ZXIgaGFuZGxlcyByZW5kZXJpbmcgdGhlIHByb3ZpZGVkIHNlZ21lbnQgYmFzZWQgb24gdGhlIGNhY2hlLlxuICovXG5mdW5jdGlvbiBJbm5lckxheW91dFJvdXRlcih7XG4gIHRyZWUsXG4gIHNlZ21lbnRQYXRoLFxuICBkZWJ1Z05hbWVDb250ZXh0LFxuICBjYWNoZU5vZGUsXG4gIHBhcmFtcyxcbiAgdXJsLFxuICBpc0FjdGl2ZSxcbn06IHtcbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgc2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoXG4gIGRlYnVnTmFtZUNvbnRleHQ6IHN0cmluZ1xuICBjYWNoZU5vZGU6IENhY2hlTm9kZVxuICBwYXJhbXM6IFBhcmFtc1xuICB1cmw6IHN0cmluZ1xuICBpc0FjdGl2ZTogYm9vbGVhblxufSkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0KVxuICBjb25zdCBwYXJlbnROYXZQcm9taXNlcyA9IHVzZUNvbnRleHQoTmF2aWdhdGlvblByb21pc2VzQ29udGV4dClcblxuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCBnbG9iYWwgbGF5b3V0IHJvdXRlciBub3QgbW91bnRlZCcpXG4gIH1cblxuICBjb25zdCB7IHRyZWU6IGZ1bGxUcmVlIH0gPSBjb250ZXh0XG5cbiAgLy8gYHJzY2AgcmVwcmVzZW50cyB0aGUgcmVuZGVyYWJsZSBub2RlIGZvciB0aGlzIHNlZ21lbnQuXG5cbiAgLy8gSWYgdGhpcyBzZWdtZW50IGhhcyBhIGBwcmVmZXRjaFJzY2AsIGl0J3MgdGhlIHN0YXRpY2FsbHkgcHJlZmV0Y2hlZCBkYXRhLlxuICAvLyBXZSBzaG91bGQgdXNlIHRoYXQgb24gaW5pdGlhbCByZW5kZXIgaW5zdGVhZCBvZiBgcnNjYC4gVGhlbiB3ZSdsbCBzd2l0Y2hcbiAgLy8gdG8gYHJzY2Agd2hlbiB0aGUgZHluYW1pYyByZXNwb25zZSBzdHJlYW1zIGluLlxuICAvL1xuICAvLyBJZiBubyBwcmVmZXRjaCBkYXRhIGlzIGF2YWlsYWJsZSwgdGhlbiB3ZSBnbyBzdHJhaWdodCB0byByZW5kZXJpbmcgYHJzY2AuXG4gIGNvbnN0IHJlc29sdmVkUHJlZmV0Y2hSc2MgPVxuICAgIGNhY2hlTm9kZS5wcmVmZXRjaFJzYyAhPT0gbnVsbCA/IGNhY2hlTm9kZS5wcmVmZXRjaFJzYyA6IGNhY2hlTm9kZS5yc2NcblxuICAvLyBXZSB1c2UgYHVzZURlZmVycmVkVmFsdWVgIHRvIGhhbmRsZSBzd2l0Y2hpbmcgYmV0d2VlbiB0aGUgcHJlZmV0Y2hlZCBhbmRcbiAgLy8gZmluYWwgdmFsdWVzLiBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIHJldHVybmVkIG9uIGluaXRpYWwgcmVuZGVyLCB0aGVuIGl0XG4gIC8vIHJlLXJlbmRlcnMgd2l0aCB0aGUgZmlyc3QgYXJndW1lbnQuXG4gIGNvbnN0IHJzYzogYW55ID0gdXNlRGVmZXJyZWRWYWx1ZShjYWNoZU5vZGUucnNjLCByZXNvbHZlZFByZWZldGNoUnNjKVxuXG4gIC8vIGByc2NgIGlzIGVpdGhlciBhIFJlYWN0IG5vZGUgb3IgYSBwcm9taXNlIGZvciBhIFJlYWN0IG5vZGUsIGV4Y2VwdCB3ZVxuICAvLyBzcGVjaWFsIGNhc2UgYG51bGxgIHRvIHJlcHJlc2VudCB0aGF0IHRoaXMgc2VnbWVudCdzIGRhdGEgaXMgbWlzc2luZy4gSWZcbiAgLy8gaXQncyBhIHByb21pc2UsIHdlIG5lZWQgdG8gdW53cmFwIGl0IHNvIHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdGhlXG4gIC8vIGRhdGEgaXMgbWlzc2luZy5cbiAgY29uc3QgcmVzb2x2ZWRSc2M6IFJlYWN0LlJlYWN0Tm9kZSA9XG4gICAgdHlwZW9mIHJzYyA9PT0gJ29iamVjdCcgJiYgcnNjICE9PSBudWxsICYmIHR5cGVvZiByc2MudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyB1c2UocnNjKVxuICAgICAgOiByc2NcblxuICBpZiAoIXJlc29sdmVkUnNjKSB7XG4gICAgLy8gVGhlIGRhdGEgZm9yIHRoaXMgc2VnbWVudCBpcyBub3QgYXZhaWxhYmxlLCBhbmQgdGhlcmUncyBubyBwZW5kaW5nXG4gICAgLy8gbmF2aWdhdGlvbiB0aGF0IHdpbGwgYmUgYWJsZSB0byBmdWxmaWxsIGl0LiBXZSBuZWVkIHRvIGZldGNoIG1vcmUgZnJvbVxuICAgIC8vIHRoZSBzZXJ2ZXIgYW5kIHBhdGNoIHRoZSBjYWNoZS5cblxuICAgIC8vIE9ubHkgZmV0Y2ggZGF0YSBmb3IgdGhlIGFjdGl2ZSBzZWdtZW50LiBJbmFjdGl2ZSBzZWdtZW50cyAocmVuZGVyZWRcbiAgICAvLyBvZmZzY3JlZW4gZm9yIGJmY2FjaGUpIHNob3VsZCBub3QgdHJpZ2dlciBmZXRjaGVzLlxuICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbHJlYWR5IGEgcGVuZGluZyByZXF1ZXN0LlxuICAgICAgbGV0IGxhenlEYXRhID0gY2FjaGVOb2RlLmxhenlEYXRhXG4gICAgICBpZiAobGF6eURhdGEgPT09IG51bGwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJvdXRlciBzdGF0ZSB3aXRoIHJlZmV0Y2ggbWFya2VyIGFkZGVkXG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgIGNvbnN0IHJlZmV0Y2hUcmVlID0gd2Fsa0FkZFJlZmV0Y2goWycnLCAuLi5zZWdtZW50UGF0aF0sIGZ1bGxUcmVlKVxuICAgICAgICBjb25zdCBpbmNsdWRlTmV4dFVybCA9IGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZShmdWxsVHJlZSlcbiAgICAgICAgY29uc3QgbmF2aWdhdGVkQXQgPSBEYXRlLm5vdygpXG4gICAgICAgIGNhY2hlTm9kZS5sYXp5RGF0YSA9IGxhenlEYXRhID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZShcbiAgICAgICAgICBuZXcgVVJMKHVybCwgbG9jYXRpb24ub3JpZ2luKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogcmVmZXRjaFRyZWUsXG4gICAgICAgICAgICBuZXh0VXJsOiBpbmNsdWRlTmV4dFVybFxuICAgICAgICAgICAgICA/IC8vIFdlIGFsd2F5cyBzZW5kIHRoZSBsYXN0IG5leHQtdXJsLCBub3QgdGhlIGN1cnJlbnQgd2hlblxuICAgICAgICAgICAgICAgIC8vIHBlcmZvcm1pbmcgYSBkeW5hbWljIHJlcXVlc3QuIFRoaXMgaXMgYmVjYXVzZSB3ZSB1cGRhdGVcbiAgICAgICAgICAgICAgICAvLyB0aGUgbmV4dC11cmwgYWZ0ZXIgYSBuYXZpZ2F0aW9uLCBidXQgd2Ugd2FudCB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vIGludGVyY2VwdGlvbiByb3V0ZSB0byBiZSBtYXRjaGVkIHRoYXQgdXNlZCB0aGUgbGFzdFxuICAgICAgICAgICAgICAgIC8vIG5leHQtdXJsLlxuICAgICAgICAgICAgICAgIGNvbnRleHQucHJldmlvdXNOZXh0VXJsIHx8IGNvbnRleHQubmV4dFVybFxuICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgfVxuICAgICAgICApLnRoZW4oKHNlcnZlclJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uKHtcbiAgICAgICAgICAgICAgdHlwZTogQUNUSU9OX1NFUlZFUl9QQVRDSCxcbiAgICAgICAgICAgICAgcHJldmlvdXNUcmVlOiBmdWxsVHJlZSxcbiAgICAgICAgICAgICAgc2VydmVyUmVzcG9uc2UsXG4gICAgICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgcmV0dXJuIHNlcnZlclJlc3BvbnNlXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gU3VzcGVuZCB3aGlsZSB3YWl0aW5nIGZvciBsYXp5RGF0YSB0byByZXNvbHZlXG4gICAgICAgIHVzZShsYXp5RGF0YSlcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gU3VzcGVuZCBpbmZpbml0ZWx5IGFzIGBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlYCB3aWxsIGNhdXNlIGEgZGlmZmVyZW50IHBhcnQgb2YgdGhlIHRyZWUgdG8gYmUgcmVuZGVyZWQuXG4gICAgLy8gQSBmYWxzZXkgYHJlc29sdmVkUnNjYCBpbmRpY2F0ZXMgbWlzc2luZyBkYXRhIC0tIHdlIHNob3VsZCBub3QgY29tbWl0IHRoYXQgYnJhbmNoLCBhbmQgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgZGF0YSB0byBhcnJpdmUuXG4gICAgdXNlKHVucmVzb2x2ZWRUaGVuYWJsZSkgYXMgbmV2ZXJcbiAgfVxuXG4gIC8vIElmIHdlIGdldCB0byB0aGlzIHBvaW50LCB0aGVuIHdlIGtub3cgd2UgaGF2ZSBzb21ldGhpbmcgd2UgY2FuIHJlbmRlci5cbiAgbGV0IGNvbnRlbnQgPSByZXNvbHZlZFJzY1xuXG4gIC8vIEluIGRldiwgd2UgY3JlYXRlIGEgTmF2aWdhdGlvblByb21pc2VzQ29udGV4dCBjb250YWluaW5nIHRoZSBpbnN0cnVtZW50ZWQgcHJvbWlzZXMgdGhhdCBwcm92aWRlXG4gIC8vIGB1c2VTZWxlY3RlZExheW91dFNlZ21lbnRgIGFuZCBgdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50c2AuXG4gIC8vIFByb21pc2VzIGFyZSBjYWNoZWQgb3V0c2lkZSBvZiByZW5kZXIgdG8gc3Vydml2ZSBzdXNwZW5zZSByZXRyaWVzLlxuICBsZXQgbmF2aWdhdGlvblByb21pc2VzOiBOYXZpZ2F0aW9uUHJvbWlzZXMgfCBudWxsID0gbnVsbFxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IHsgY3JlYXRlTmVzdGVkTGF5b3V0TmF2aWdhdGlvblByb21pc2VzIH0gPVxuICAgICAgcmVxdWlyZSgnLi9uYXZpZ2F0aW9uLWRldnRvb2xzJykgYXMgdHlwZW9mIGltcG9ydCgnLi9uYXZpZ2F0aW9uLWRldnRvb2xzJylcblxuICAgIG5hdmlnYXRpb25Qcm9taXNlcyA9IGNyZWF0ZU5lc3RlZExheW91dE5hdmlnYXRpb25Qcm9taXNlcyhcbiAgICAgIHRyZWUsXG4gICAgICBwYXJlbnROYXZQcm9taXNlc1xuICAgIClcbiAgfVxuXG4gIGlmIChuYXZpZ2F0aW9uUHJvbWlzZXMpIHtcbiAgICBjb250ZW50ID0gKFxuICAgICAgPE5hdmlnYXRpb25Qcm9taXNlc0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e25hdmlnYXRpb25Qcm9taXNlc30+XG4gICAgICAgIHtyZXNvbHZlZFJzY31cbiAgICAgIDwvTmF2aWdhdGlvblByb21pc2VzQ29udGV4dC5Qcm92aWRlcj5cbiAgICApXG4gIH1cblxuICBjb25zdCBzdWJ0cmVlID0gKFxuICAgIC8vIFRoZSBsYXlvdXQgcm91dGVyIGNvbnRleHQgbmFycm93cyBkb3duIHRyZWUgYW5kIGNoaWxkTm9kZXMgYXQgZWFjaCBsZXZlbC5cbiAgICA8TGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlclxuICAgICAgdmFsdWU9e3tcbiAgICAgICAgcGFyZW50VHJlZTogdHJlZSxcbiAgICAgICAgcGFyZW50Q2FjaGVOb2RlOiBjYWNoZU5vZGUsXG4gICAgICAgIHBhcmVudFNlZ21lbnRQYXRoOiBzZWdtZW50UGF0aCxcbiAgICAgICAgcGFyZW50UGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIGRlYnVnTmFtZUNvbnRleHQ6IGRlYnVnTmFtZUNvbnRleHQsXG5cbiAgICAgICAgLy8gVE9ETy1BUFA6IG92ZXJyaWRpbmcgb2YgdXJsIGZvciBwYXJhbGxlbCByb3V0ZXNcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGlzQWN0aXZlOiBpc0FjdGl2ZSxcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NvbnRlbnR9XG4gICAgPC9MYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICApXG4gIC8vIEVuc3VyZSByb290IGxheW91dCBpcyBub3Qgd3JhcHBlZCBpbiBhIGRpdiBhcyB0aGUgcm9vdCBsYXlvdXQgcmVuZGVycyBgPGh0bWw+YFxuICByZXR1cm4gc3VidHJlZVxufVxuXG4vKipcbiAqIFJlbmRlcnMgc3VzcGVuc2UgYm91bmRhcnkgd2l0aCB0aGUgcHJvdmlkZWQgXCJsb2FkaW5nXCIgcHJvcGVydHkgYXMgdGhlIGZhbGxiYWNrLlxuICogSWYgbm8gbG9hZGluZyBwcm9wZXJ0eSBpcyBwcm92aWRlZCBpdCByZW5kZXJzIHRoZSBjaGlsZHJlbiB3aXRob3V0IGEgc3VzcGVuc2UgYm91bmRhcnkuXG4gKi9cbmZ1bmN0aW9uIExvYWRpbmdCb3VuZGFyeSh7XG4gIG5hbWUsXG4gIGxvYWRpbmcsXG4gIGNoaWxkcmVuLFxufToge1xuICBuYW1lOiBBY3Rpdml0eVByb3BzWyduYW1lJ11cbiAgbG9hZGluZzogTG9hZGluZ01vZHVsZURhdGEgfCBQcm9taXNlPExvYWRpbmdNb2R1bGVEYXRhPlxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG59KTogSlNYLkVsZW1lbnQge1xuICAvLyBJZiBsb2FkaW5nIGlzIGEgcHJvbWlzZSwgdW53cmFwIGl0LiBUaGlzIGhhcHBlbnMgaW4gY2FzZXMgd2hlcmUgd2UgaGF2ZW4ndFxuICAvLyB5ZXQgcmVjZWl2ZWQgdGhlIGxvYWRpbmcgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIg4oCUIHdoaWNoIGluY2x1ZGVzIHdoZXRoZXIgb3JcbiAgLy8gbm90IHRoaXMgbGF5b3V0IGhhcyBhIGxvYWRpbmcgY29tcG9uZW50IGF0IGFsbC5cbiAgLy9cbiAgLy8gSXQncyBPSyB0byBzdXNwZW5kIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGUgdGhlIGZhbGxiYWNrIGJlY2F1c2UgdGhpc1xuICAvLyBwcm9taXNlIHdpbGwgcmVzb2x2ZSBzaW11bHRhbmVvdXNseSB3aXRoIHRoZSBkYXRhIGZvciB0aGUgc2VnbWVudCBpdHNlbGYuXG4gIC8vIFNvIGl0IHdpbGwgbmV2ZXIgc3VzcGVuZCBmb3IgbG9uZ2VyIHRoYW4gaXQgd291bGQgaGF2ZSBpZiB3ZSBkaWRuJ3QgdXNlXG4gIC8vIGEgU3VzcGVuc2UgZmFsbGJhY2sgYXQgYWxsLlxuICBsZXQgbG9hZGluZ01vZHVsZURhdGFcbiAgaWYgKFxuICAgIHR5cGVvZiBsb2FkaW5nID09PSAnb2JqZWN0JyAmJlxuICAgIGxvYWRpbmcgIT09IG51bGwgJiZcbiAgICB0eXBlb2YgKGxvYWRpbmcgYXMgYW55KS50aGVuID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIGNvbnN0IHByb21pc2VGb3JMb2FkaW5nID0gbG9hZGluZyBhcyBQcm9taXNlPExvYWRpbmdNb2R1bGVEYXRhPlxuICAgIGxvYWRpbmdNb2R1bGVEYXRhID0gdXNlKHByb21pc2VGb3JMb2FkaW5nKVxuICB9IGVsc2Uge1xuICAgIGxvYWRpbmdNb2R1bGVEYXRhID0gbG9hZGluZyBhcyBMb2FkaW5nTW9kdWxlRGF0YVxuICB9XG5cbiAgaWYgKGxvYWRpbmdNb2R1bGVEYXRhKSB7XG4gICAgY29uc3QgbG9hZGluZ1JzYyA9IGxvYWRpbmdNb2R1bGVEYXRhWzBdXG4gICAgY29uc3QgbG9hZGluZ1N0eWxlcyA9IGxvYWRpbmdNb2R1bGVEYXRhWzFdXG4gICAgY29uc3QgbG9hZGluZ1NjcmlwdHMgPSBsb2FkaW5nTW9kdWxlRGF0YVsyXVxuICAgIHJldHVybiAoXG4gICAgICA8U3VzcGVuc2VcbiAgICAgICAgbmFtZT17bmFtZX1cbiAgICAgICAgZmFsbGJhY2s9e1xuICAgICAgICAgIDw+XG4gICAgICAgICAgICB7bG9hZGluZ1N0eWxlc31cbiAgICAgICAgICAgIHtsb2FkaW5nU2NyaXB0c31cbiAgICAgICAgICAgIHtsb2FkaW5nUnNjfVxuICAgICAgICAgIDwvPlxuICAgICAgICB9XG4gICAgICA+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvU3VzcGVuc2U+XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIDw+e2NoaWxkcmVufTwvPlxufVxuXG4vKipcbiAqIE91dGVyTGF5b3V0Um91dGVyIGhhbmRsZXMgdGhlIGN1cnJlbnQgc2VnbWVudCBhcyB3ZWxsIGFzIDxPZmZzY3JlZW4+IHJlbmRlcmluZyBvZiBvdGhlciBzZWdtZW50cy5cbiAqIEl0IGNhbiBiZSByZW5kZXJlZCBuZXh0IHRvIGVhY2ggb3RoZXIgd2l0aCBhIGRpZmZlcmVudCBgcGFyYWxsZWxSb3V0ZXJLZXlgLCBhbGxvd2luZyBmb3IgUGFyYWxsZWwgcm91dGVzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBPdXRlckxheW91dFJvdXRlcih7XG4gIHBhcmFsbGVsUm91dGVyS2V5LFxuICBlcnJvcixcbiAgZXJyb3JTdHlsZXMsXG4gIGVycm9yU2NyaXB0cyxcbiAgdGVtcGxhdGVTdHlsZXMsXG4gIHRlbXBsYXRlU2NyaXB0cyxcbiAgdGVtcGxhdGUsXG4gIG5vdEZvdW5kLFxuICBmb3JiaWRkZW4sXG4gIHVuYXV0aG9yaXplZCxcbiAgc2VnbWVudFZpZXdCb3VuZGFyaWVzLFxufToge1xuICBwYXJhbGxlbFJvdXRlcktleTogc3RyaW5nXG4gIGVycm9yOiBFcnJvckNvbXBvbmVudCB8IHVuZGVmaW5lZFxuICBlcnJvclN0eWxlczogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkXG4gIGVycm9yU2NyaXB0czogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkXG4gIHRlbXBsYXRlU3R5bGVzOiBSZWFjdC5SZWFjdE5vZGUgfCB1bmRlZmluZWRcbiAgdGVtcGxhdGVTY3JpcHRzOiBSZWFjdC5SZWFjdE5vZGUgfCB1bmRlZmluZWRcbiAgdGVtcGxhdGU6IFJlYWN0LlJlYWN0Tm9kZVxuICBub3RGb3VuZDogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkXG4gIGZvcmJpZGRlbjogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkXG4gIHVuYXV0aG9yaXplZDogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkXG4gIHNlZ21lbnRWaWV3Qm91bmRhcmllcz86IFJlYWN0LlJlYWN0Tm9kZVxufSkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChMYXlvdXRSb3V0ZXJDb250ZXh0KVxuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCBleHBlY3RlZCBsYXlvdXQgcm91dGVyIHRvIGJlIG1vdW50ZWQnKVxuICB9XG5cbiAgY29uc3Qge1xuICAgIHBhcmVudFRyZWUsXG4gICAgcGFyZW50Q2FjaGVOb2RlLFxuICAgIHBhcmVudFNlZ21lbnRQYXRoLFxuICAgIHBhcmVudFBhcmFtcyxcbiAgICB1cmwsXG4gICAgaXNBY3RpdmUsXG4gICAgZGVidWdOYW1lQ29udGV4dCxcbiAgfSA9IGNvbnRleHRcblxuICAvLyBHZXQgdGhlIENhY2hlTm9kZSBmb3IgdGhpcyBzZWdtZW50IGJ5IHJlYWRpbmcgaXQgZnJvbSB0aGUgcGFyZW50IHNlZ21lbnQnc1xuICAvLyBjaGlsZCBtYXAuXG4gIGNvbnN0IHBhcmVudFBhcmFsbGVsUm91dGVzID0gcGFyZW50Q2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzXG4gIGxldCBzZWdtZW50TWFwID0gcGFyZW50UGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVyS2V5KVxuICAvLyBJZiB0aGUgcGFyYWxsZWwgcm91dGVyIGNhY2hlIG5vZGUgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuXG4gIC8vIFRoaXMgd3JpdGVzIHRvIHRoZSBjYWNoZSB3aGVuIHRoZXJlIGlzIG5vIGl0ZW0gaW4gdGhlIGNhY2hlIHlldC4gSXQgbmV2ZXIgKm92ZXJ3cml0ZXMqIGV4aXN0aW5nIGNhY2hlIGl0ZW1zIHdoaWNoIGlzIHdoeSBpdCdzIHNhZmUgaW4gY29uY3VycmVudCBtb2RlLlxuICBpZiAoIXNlZ21lbnRNYXApIHtcbiAgICBzZWdtZW50TWFwID0gbmV3IE1hcCgpXG4gICAgcGFyZW50UGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVyS2V5LCBzZWdtZW50TWFwKVxuICB9XG4gIGNvbnN0IHBhcmVudFRyZWVTZWdtZW50ID0gcGFyZW50VHJlZVswXVxuICBjb25zdCBzZWdtZW50UGF0aCA9XG4gICAgcGFyZW50U2VnbWVudFBhdGggPT09IG51bGxcbiAgICAgID8gLy8gVE9ETzogVGhlIHJvb3Qgc2VnbWVudCB2YWx1ZSBpcyBjdXJyZW50bHkgb21pdHRlZCBmcm9tIHRoZSBzZWdtZW50XG4gICAgICAgIC8vIHBhdGguIFRoaXMgaGFzIGxlZCB0byBhIGJ1bmNoIG9mIHNwZWNpYWwgY2FzZXMgc2NhdHRlcmVkIHRocm91Z2hvdXRcbiAgICAgICAgLy8gdGhlIGNvZGUuIFdlIHNob3VsZCBjbGVhbiB0aGlzIHVwLlxuICAgICAgICBbcGFyYWxsZWxSb3V0ZXJLZXldXG4gICAgICA6IHBhcmVudFNlZ21lbnRQYXRoLmNvbmNhdChbcGFyZW50VHJlZVNlZ21lbnQsIHBhcmFsbGVsUm91dGVyS2V5XSlcblxuICAvLyBUaGUgXCJzdGF0ZVwiIGtleSBvZiBhIHNlZ21lbnQgaXMgdGhlIG9uZSBwYXNzZWQgdG8gUmVhY3Qg4oCUIGl0IHJlcHJlc2VudHMgdGhlXG4gIC8vIGlkZW50aXR5IG9mIHRoZSBVSSB0cmVlLiBXaGVuZXZlciB0aGUgc3RhdGUga2V5IGNoYW5nZXMsIHRoZSB0cmVlIGlzXG4gIC8vIHJlY3JlYXRlZCBhbmQgdGhlIHN0YXRlIGlzIHJlc2V0LiBJbiB0aGUgQXBwIFJvdXRlciBtb2RlbCwgc2VhcmNoIHBhcmFtcyBkb1xuICAvLyBub3QgY2F1c2Ugc3RhdGUgdG8gYmUgbG9zdCwgc28gdHdvIHNlZ21lbnRzIHdpdGggdGhlIHNhbWUgc2VnbWVudCBwYXRoIGJ1dFxuICAvLyBkaWZmZXJlbnQgc2VhcmNoIHBhcmFtcyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBzdGF0ZSBrZXkuXG4gIC8vXG4gIC8vIFRoZSBcImNhY2hlXCIga2V5IG9mIGEgc2VnbWVudCwgaG93ZXZlciwgKmRvZXMqIGluY2x1ZGUgdGhlIHNlYXJjaCBwYXJhbXMsIGlmXG4gIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgc2VnbWVudCBhY2Nlc3NlZCB0aGUgc2VhcmNoIHBhcmFtcyBvbiB0aGUgc2VydmVyLlxuICAvLyAoVGhpcyBvbmx5IGFwcGxpZXMgdG8gcGFnZSBzZWdtZW50czsgbGF5b3V0IHNlZ21lbnRzIGNhbm5vdCBhY2Nlc3Mgc2VhcmNoXG4gIC8vIHBhcmFtcyBvbiB0aGUgc2VydmVyLilcbiAgY29uc3QgYWN0aXZlVHJlZSA9IHBhcmVudFRyZWVbMV1bcGFyYWxsZWxSb3V0ZXJLZXldXG4gIGNvbnN0IGFjdGl2ZVNlZ21lbnQgPSBhY3RpdmVUcmVlWzBdXG4gIGNvbnN0IGFjdGl2ZVN0YXRlS2V5ID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoYWN0aXZlU2VnbWVudCwgdHJ1ZSkgLy8gbm8gc2VhcmNoIHBhcmFtc1xuXG4gIC8vIEF0IGVhY2ggbGV2ZWwgb2YgdGhlIHJvdXRlIHRyZWUsIG5vdCBvbmx5IGRvIHdlIHJlbmRlciB0aGUgY3VycmVudGx5XG4gIC8vIGFjdGl2ZSBzZWdtZW50IOKAlCB3ZSBhbHNvIHJlbmRlciB0aGUgbGFzdCBOIHNlZ21lbnRzIHRoYXQgd2VyZSBhY3RpdmUgYXRcbiAgLy8gdGhpcyBsZXZlbCBpbnNpZGUgYSBoaWRkZW4gPEFjdGl2aXR5PiBib3VuZGFyeSwgdG8gcHJlc2VydmUgdGhlaXIgc3RhdGVcbiAgLy8gaWYgb3Igd2hlbiB0aGUgdXNlciBuYXZpZ2F0ZXMgdG8gdGhlbSBhZ2Fpbi5cbiAgLy9cbiAgLy8gYmZjYWNoZUVudHJ5IGlzIGEgbGlua2VkIGxpc3Qgb2YgRmxpZ2h0Um91dGVyU3RhdGVzLlxuICBsZXQgYmZjYWNoZUVudHJ5OiBSb3V0ZXJCRkNhY2hlRW50cnkgfCBudWxsID0gdXNlUm91dGVyQkZDYWNoZShcbiAgICBhY3RpdmVUcmVlLFxuICAgIGFjdGl2ZVN0YXRlS2V5XG4gIClcbiAgbGV0IGNoaWxkcmVuOiBBcnJheTxSZWFjdC5SZWFjdE5vZGU+ID0gW11cbiAgZG8ge1xuICAgIGNvbnN0IHRyZWUgPSBiZmNhY2hlRW50cnkudHJlZVxuICAgIGNvbnN0IHN0YXRlS2V5ID0gYmZjYWNoZUVudHJ5LnN0YXRlS2V5XG4gICAgY29uc3Qgc2VnbWVudCA9IHRyZWVbMF1cbiAgICBjb25zdCBjYWNoZUtleSA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHNlZ21lbnQpXG5cbiAgICAvLyBSZWFkIHNlZ21lbnQgcGF0aCBmcm9tIHRoZSBwYXJhbGxlbCByb3V0ZXIgY2FjaGUgbm9kZS5cbiAgICBsZXQgY2FjaGVOb2RlID0gc2VnbWVudE1hcC5nZXQoY2FjaGVLZXkpXG4gICAgaWYgKGNhY2hlTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBXaGVuIGRhdGEgaXMgbm90IGF2YWlsYWJsZSBkdXJpbmcgcmVuZGVyaW5nIGNsaWVudC1zaWRlIHdlIG5lZWQgdG8gZmV0Y2hcbiAgICAgIC8vIGl0IGZyb20gdGhlIHNlcnZlci5cbiAgICAgIGNvbnN0IG5ld0xhenlDYWNoZU5vZGU6IExhenlDYWNoZU5vZGUgPSB7XG4gICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICByc2M6IG51bGwsXG4gICAgICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgICAgICBoZWFkOiBudWxsLFxuICAgICAgICBwcmVmZXRjaEhlYWQ6IG51bGwsXG4gICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKCksXG4gICAgICAgIGxvYWRpbmc6IG51bGwsXG4gICAgICAgIG5hdmlnYXRlZEF0OiAtMSxcbiAgICAgIH1cblxuICAgICAgLy8gRmxpZ2h0IGRhdGEgZmV0Y2gga2lja2VkIG9mZiBkdXJpbmcgcmVuZGVyIGFuZCBwdXQgaW50byB0aGUgY2FjaGUuXG4gICAgICBjYWNoZU5vZGUgPSBuZXdMYXp5Q2FjaGVOb2RlXG4gICAgICBzZWdtZW50TWFwLnNldChjYWNoZUtleSwgbmV3TGF6eUNhY2hlTm9kZSlcbiAgICB9XG5cbiAgICAvKlxuICAgIC0gRXJyb3IgYm91bmRhcnlcbiAgICAgIC0gT25seSByZW5kZXJzIGVycm9yIGJvdW5kYXJ5IGlmIGVycm9yIGNvbXBvbmVudCBpcyBwcm92aWRlZC5cbiAgICAgIC0gUmVuZGVyZWQgZm9yIGVhY2ggc2VnbWVudCB0byBlbnN1cmUgdGhleSBoYXZlIHRoZWlyIG93biBlcnJvciBzdGF0ZS5cbiAgICAgIC0gV2hlbiBncmFjZWZ1bGx5IGRlZ3JhZGUgZm9yIGJvdHMsIHNraXAgcmVuZGVyaW5nIGVycm9yIGJvdW5kYXJ5LlxuICAgIC0gTG9hZGluZyBib3VuZGFyeVxuICAgICAgLSBPbmx5IHJlbmRlcnMgc3VzcGVuc2UgYm91bmRhcnkgaWYgbG9hZGluZyBjb21wb25lbnRzIGlzIHByb3ZpZGVkLlxuICAgICAgLSBSZW5kZXJlZCBmb3IgZWFjaCBzZWdtZW50IHRvIGVuc3VyZSB0aGV5IGhhdmUgdGhlaXIgb3duIGxvYWRpbmcgc3RhdGUuXG4gICAgICAtIFBhc3NlZCB0byB0aGUgcm91dGVyIGR1cmluZyByZW5kZXJpbmcgdG8gZW5zdXJlIGl0IGNhbiBiZSBpbW1lZGlhdGVseSByZW5kZXJlZCB3aGVuIHN1c3BlbmRpbmcgb24gYSBGbGlnaHQgZmV0Y2guXG4gICovXG5cbiAgICBsZXQgc2VnbWVudEJvdW5kYXJ5VHJpZ2dlck5vZGU6IFJlYWN0LlJlYWN0Tm9kZSA9IG51bGxcbiAgICBsZXQgc2VnbWVudFZpZXdTdGF0ZU5vZGU6IFJlYWN0LlJlYWN0Tm9kZSA9IG51bGxcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc3QgeyBTZWdtZW50Qm91bmRhcnlUcmlnZ2VyTm9kZSwgU2VnbWVudFZpZXdTdGF0ZU5vZGUgfSA9XG4gICAgICAgIHJlcXVpcmUoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9zZWdtZW50LWV4cGxvcmVyLW5vZGUnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvc2VnbWVudC1leHBsb3Jlci1ub2RlJylcblxuICAgICAgY29uc3QgcGFnZVByZWZpeCA9IG5vcm1hbGl6ZUFwcFBhdGgodXJsKVxuICAgICAgc2VnbWVudFZpZXdTdGF0ZU5vZGUgPSAoXG4gICAgICAgIDxTZWdtZW50Vmlld1N0YXRlTm9kZSBrZXk9e3BhZ2VQcmVmaXh9IHBhZ2U9e3BhZ2VQcmVmaXh9IC8+XG4gICAgICApXG5cbiAgICAgIHNlZ21lbnRCb3VuZGFyeVRyaWdnZXJOb2RlID0gKFxuICAgICAgICA8PlxuICAgICAgICAgIDxTZWdtZW50Qm91bmRhcnlUcmlnZ2VyTm9kZSAvPlxuICAgICAgICA8Lz5cbiAgICAgIClcbiAgICB9XG5cbiAgICBsZXQgcGFyYW1zID0gcGFyZW50UGFyYW1zXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2VnbWVudCkpIHtcbiAgICAgIC8vIFRoaXMgc2VnbWVudCBjb250YWlucyBhIHJvdXRlIHBhcmFtLiBBY2N1bXVsYXRlIHRoZXNlIGFzIHdlIHRyYXZlcnNlXG4gICAgICAvLyBkb3duIHRoZSByb3V0ZXIgdHJlZS4gVGhlIHJlc3VsdCByZXByZXNlbnRzIHRoZSBzZXQgb2YgcGFyYW1zIHRoYXRcbiAgICAgIC8vIHRoZSBsYXlvdXQvcGFnZSBjb21wb25lbnRzIGFyZSBwZXJtaXR0ZWQgdG8gYWNjZXNzIGJlbG93IHRoaXMgcG9pbnQuXG4gICAgICBjb25zdCBwYXJhbU5hbWUgPSBzZWdtZW50WzBdXG4gICAgICBjb25zdCBwYXJhbUNhY2hlS2V5ID0gc2VnbWVudFsxXVxuICAgICAgY29uc3QgcGFyYW1UeXBlID0gc2VnbWVudFsyXVxuICAgICAgY29uc3QgcGFyYW1WYWx1ZSA9IGdldFBhcmFtVmFsdWVGcm9tQ2FjaGVLZXkocGFyYW1DYWNoZUtleSwgcGFyYW1UeXBlKVxuICAgICAgaWYgKHBhcmFtVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgIC4uLnBhcmVudFBhcmFtcyxcbiAgICAgICAgICBbcGFyYW1OYW1lXTogcGFyYW1WYWx1ZSxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGRlYnVnTmFtZSA9IGdldEJvdW5kYXJ5RGVidWdOYW1lRnJvbVNlZ21lbnQoc2VnbWVudClcbiAgICAvLyBgZGVidWdOYW1lQ29udGV4dGAgcmVwcmVzZW50cyB0aGUgbmVhcmVzdCBub24tXCJ2aXJ0dWFsXCIgcGFyZW50IHNlZ21lbnQuXG4gICAgLy8gYGdldEJvdW5kYXJ5RGVidWdOYW1lRnJvbVNlZ21lbnRgIHJldHVybnMgdW5kZWZpbmVkIGZvciB2aXJ0dWFsIHNlZ21lbnRzLlxuICAgIC8vIFNvIGlmIGBkZWJ1Z05hbWVgIGlzIHVuZGVmaW5lZCwgdGhlIGNvbnRleHQgaXMgcGFzc2VkIHRocm91Z2ggdW5jaGFuZ2VkLlxuICAgIGNvbnN0IGNoaWxkRGVidWdOYW1lQ29udGV4dCA9IGRlYnVnTmFtZSA/PyBkZWJ1Z05hbWVDb250ZXh0XG5cbiAgICAvLyBJbiBwcmFjdGljYWwgdGVybXMsIGNsaWNraW5nIHRoaXMgbmFtZSBpbiB0aGUgU3VzcGVuc2UgRGV2VG9vbHNcbiAgICAvLyBzaG91bGQgc2VsZWN0IHRoZSBjaGlsZCBzbG90cyBvZiB0aGF0IGxheW91dC5cbiAgICAvL1xuICAgIC8vIFNvIHRoZSBuYW1lIHdlIGFwcGx5IHRvIHRoZSBBY3Rpdml0eSBib3VuZGFyeSBpcyBhY3R1YWxseSBiYXNlZCBvblxuICAgIC8vIHRoZSBuZWFyZXN0IHBhcmVudCBzZWdtZW50cy5cbiAgICAvL1xuICAgIC8vIFdlIHNraXAgb3ZlciBcInZpcnR1YWxcIiBwYXJlbnRzLCBpLmUuIG9uZXMgaW5zZXJ0ZWQgYnkgTmV4dC5qcyB0aGF0XG4gICAgLy8gZG9uJ3QgY29ycmVzcG9uZCB0byBhcHBsaWNhdGlvbi1kZWZpbmVkIGNvZGUuXG4gICAgY29uc3QgaXNWaXJ0dWFsID0gZGVidWdOYW1lID09PSB1bmRlZmluZWRcbiAgICBjb25zdCBkZWJ1Z05hbWVUb0Rpc3BsYXkgPSBpc1ZpcnR1YWwgPyB1bmRlZmluZWQgOiBkZWJ1Z05hbWVDb250ZXh0XG5cbiAgICAvLyBUT0RPOiBUaGUgbG9hZGluZyBtb2R1bGUgZGF0YSBmb3IgYSBzZWdtZW50IGlzIHN0b3JlZCBvbiB0aGUgcGFyZW50LCB0aGVuXG4gICAgLy8gYXBwbGllZCB0byBlYWNoIG9mIHRoYXQgcGFyZW50IHNlZ21lbnQncyBwYXJhbGxlbCByb3V0ZSBzbG90cy4gSW4gdGhlXG4gICAgLy8gc2ltcGxlIGNhc2Ugd2hlcmUgdGhlcmUncyBvbmx5IG9uZSBwYXJhbGxlbCByb3V0ZSAodGhlIGBjaGlsZHJlbmAgc2xvdCksXG4gICAgLy8gdGhpcyBpcyBubyBkaWZmZXJlbnQgZnJvbSBpZiB0aGUgbG9hZGluZyBtb2R1bGUgZGF0YSB3aGVyZSBzdG9yZWQgb24gdGhlXG4gICAgLy8gY2hpbGQgZGlyZWN0bHkuIEJ1dCBJJ20gbm90IHN1cmUgdGhpcyBhY3R1YWxseSBtYWtlcyBzZW5zZSB3aGVuIHRoZXJlIGFyZVxuICAgIC8vIG11bHRpcGxlIHBhcmFsbGVsIHJvdXRlcy4gSXQncyBub3QgYSBodWdlIGlzc3VlIGJlY2F1c2UgeW91IGFsd2F5cyBoYXZlXG4gICAgLy8gdGhlIG9wdGlvbiB0byBkZWZpbmUgYSBuYXJyb3dlciBsb2FkaW5nIGJvdW5kYXJ5IGZvciBhIHBhcnRpY3VsYXIgc2xvdC4gQnV0XG4gICAgLy8gdGhpcyBzb3J0IG9mIHNtZWxscyBsaWtlIGFuIGltcGxlbWVudGF0aW9uIGFjY2lkZW50IHRvIG1lLlxuICAgIGNvbnN0IGxvYWRpbmdNb2R1bGVEYXRhID0gcGFyZW50Q2FjaGVOb2RlLmxvYWRpbmdcbiAgICBsZXQgY2hpbGQgPSAoXG4gICAgICA8VGVtcGxhdGVDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgIGtleT17c3RhdGVLZXl9XG4gICAgICAgIHZhbHVlPXtcbiAgICAgICAgICA8U2Nyb2xsQW5kRm9jdXNIYW5kbGVyIHNlZ21lbnRQYXRoPXtzZWdtZW50UGF0aH0+XG4gICAgICAgICAgICA8RXJyb3JCb3VuZGFyeVxuICAgICAgICAgICAgICBlcnJvckNvbXBvbmVudD17ZXJyb3J9XG4gICAgICAgICAgICAgIGVycm9yU3R5bGVzPXtlcnJvclN0eWxlc31cbiAgICAgICAgICAgICAgZXJyb3JTY3JpcHRzPXtlcnJvclNjcmlwdHN9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxMb2FkaW5nQm91bmRhcnlcbiAgICAgICAgICAgICAgICBuYW1lPXtkZWJ1Z05hbWVUb0Rpc3BsYXl9XG4gICAgICAgICAgICAgICAgbG9hZGluZz17bG9hZGluZ01vZHVsZURhdGF9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8SFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnlcbiAgICAgICAgICAgICAgICAgIG5vdEZvdW5kPXtub3RGb3VuZH1cbiAgICAgICAgICAgICAgICAgIGZvcmJpZGRlbj17Zm9yYmlkZGVufVxuICAgICAgICAgICAgICAgICAgdW5hdXRob3JpemVkPXt1bmF1dGhvcml6ZWR9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPFJlZGlyZWN0Qm91bmRhcnk+XG4gICAgICAgICAgICAgICAgICAgIDxJbm5lckxheW91dFJvdXRlclxuICAgICAgICAgICAgICAgICAgICAgIHVybD17dXJsfVxuICAgICAgICAgICAgICAgICAgICAgIHRyZWU9e3RyZWV9XG4gICAgICAgICAgICAgICAgICAgICAgcGFyYW1zPXtwYXJhbXN9XG4gICAgICAgICAgICAgICAgICAgICAgY2FjaGVOb2RlPXtjYWNoZU5vZGV9XG4gICAgICAgICAgICAgICAgICAgICAgc2VnbWVudFBhdGg9e3NlZ21lbnRQYXRofVxuICAgICAgICAgICAgICAgICAgICAgIGRlYnVnTmFtZUNvbnRleHQ9e2NoaWxkRGVidWdOYW1lQ29udGV4dH1cbiAgICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZT17aXNBY3RpdmUgJiYgc3RhdGVLZXkgPT09IGFjdGl2ZVN0YXRlS2V5fVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICB7c2VnbWVudEJvdW5kYXJ5VHJpZ2dlck5vZGV9XG4gICAgICAgICAgICAgICAgICA8L1JlZGlyZWN0Qm91bmRhcnk+XG4gICAgICAgICAgICAgICAgPC9IVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeT5cbiAgICAgICAgICAgICAgPC9Mb2FkaW5nQm91bmRhcnk+XG4gICAgICAgICAgICA8L0Vycm9yQm91bmRhcnk+XG4gICAgICAgICAgICB7c2VnbWVudFZpZXdTdGF0ZU5vZGV9XG4gICAgICAgICAgPC9TY3JvbGxBbmRGb2N1c0hhbmRsZXI+XG4gICAgICAgIH1cbiAgICAgID5cbiAgICAgICAge3RlbXBsYXRlU3R5bGVzfVxuICAgICAgICB7dGVtcGxhdGVTY3JpcHRzfVxuICAgICAgICB7dGVtcGxhdGV9XG4gICAgICA8L1RlbXBsYXRlQ29udGV4dC5Qcm92aWRlcj5cbiAgICApXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc3QgeyBTZWdtZW50U3RhdGVQcm92aWRlciB9ID1cbiAgICAgICAgcmVxdWlyZSgnLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL3NlZ21lbnQtZXhwbG9yZXItbm9kZScpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9zZWdtZW50LWV4cGxvcmVyLW5vZGUnKVxuXG4gICAgICBjaGlsZCA9IChcbiAgICAgICAgPFNlZ21lbnRTdGF0ZVByb3ZpZGVyIGtleT17c3RhdGVLZXl9PlxuICAgICAgICAgIHtjaGlsZH1cbiAgICAgICAgICB7c2VnbWVudFZpZXdCb3VuZGFyaWVzfVxuICAgICAgICA8L1NlZ21lbnRTdGF0ZVByb3ZpZGVyPlxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0FDSEVfQ09NUE9ORU5UUykge1xuICAgICAgY2hpbGQgPSAoXG4gICAgICAgIDxBY3Rpdml0eVxuICAgICAgICAgIG5hbWU9e2RlYnVnTmFtZVRvRGlzcGxheX1cbiAgICAgICAgICBrZXk9e3N0YXRlS2V5fVxuICAgICAgICAgIG1vZGU9e3N0YXRlS2V5ID09PSBhY3RpdmVTdGF0ZUtleSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nfVxuICAgICAgICA+XG4gICAgICAgICAge2NoaWxkfVxuICAgICAgICA8L0FjdGl2aXR5PlxuICAgICAgKVxuICAgIH1cblxuICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpXG5cbiAgICBiZmNhY2hlRW50cnkgPSBiZmNhY2hlRW50cnkubmV4dFxuICB9IHdoaWxlIChiZmNhY2hlRW50cnkgIT09IG51bGwpXG5cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kYXJ5RGVidWdOYW1lRnJvbVNlZ21lbnQoc2VnbWVudDogU2VnbWVudCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmIChzZWdtZW50ID09PSAnLycpIHtcbiAgICAvLyBSZWFjaGVkIHRoZSByb290XG4gICAgcmV0dXJuICcvJ1xuICB9XG4gIGlmICh0eXBlb2Ygc2VnbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoaXNWaXJ0dWFsTGF5b3V0KHNlZ21lbnQpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzZWdtZW50ICsgJy8nXG4gICAgfVxuICB9XG4gIGNvbnN0IHBhcmFtQ2FjaGVLZXkgPSBzZWdtZW50WzFdXG4gIHJldHVybiBwYXJhbUNhY2hlS2V5ICsgJy8nXG59XG5cbmZ1bmN0aW9uIGlzVmlydHVhbExheW91dChzZWdtZW50OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICAvLyBUaGlzIGlzIGluc2VydGVkIGJ5IHRoZSBsb2FkZXIuIFdlIHNob3VsZCBjb25zaWRlciBlbmNvZGluZyB0aGVzZVxuICAgIC8vIGluIGEgbW9yZSBzcGVjaWFsIHdheSBpbnN0ZWFkIG9mIGNoZWNraW5nIHRoZSBuYW1lLCB0byBkaXN0aW5ndWlzaCB0aGVtXG4gICAgLy8gZnJvbSBhcHAtZGVmaW5lZCBncm91cHMuXG4gICAgc2VnbWVudCA9PT0gJyhzbG90KSdcbiAgKVxufVxuIl0sIm5hbWVzIjpbIk91dGVyTGF5b3V0Um91dGVyIiwid2Fsa0FkZFJlZmV0Y2giLCJzZWdtZW50UGF0aFRvV2FsayIsInRyZWVUb1JlY3JlYXRlIiwic2VnbWVudCIsInBhcmFsbGVsUm91dGVLZXkiLCJpc0xhc3QiLCJsZW5ndGgiLCJtYXRjaFNlZ21lbnQiLCJoYXNPd25Qcm9wZXJ0eSIsInN1YlRyZWUiLCJ1bmRlZmluZWQiLCJzbGljZSIsIl9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSIsIlJlYWN0RE9NIiwiZmluZERPTU5vZGUiLCJpbnN0YW5jZSIsIndpbmRvdyIsImludGVybmFsX3JlYWN0RE9NZmluZERPTU5vZGUiLCJyZWN0UHJvcGVydGllcyIsInNob3VsZFNraXBFbGVtZW50IiwiZWxlbWVudCIsImluY2x1ZGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInBvc2l0aW9uIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImV2ZXJ5IiwiaXRlbSIsInRvcE9mRWxlbWVudEluVmlld3BvcnQiLCJ2aWV3cG9ydEhlaWdodCIsInRvcCIsImdldEhhc2hGcmFnbWVudERvbU5vZGUiLCJoYXNoRnJhZ21lbnQiLCJkb2N1bWVudCIsImJvZHkiLCJnZXRFbGVtZW50QnlJZCIsImdldEVsZW1lbnRzQnlOYW1lIiwiSW5uZXJTY3JvbGxBbmRGb2N1c0hhbmRsZXIiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbXBvbmVudERpZE1vdW50IiwiaGFuZGxlUG90ZW50aWFsU2Nyb2xsIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJvcHMiLCJmb2N1c0FuZFNjcm9sbFJlZiIsImFwcGx5IiwicmVuZGVyIiwiY2hpbGRyZW4iLCJzZWdtZW50UGF0aCIsInNlZ21lbnRQYXRocyIsInNvbWUiLCJzY3JvbGxSZWZTZWdtZW50UGF0aCIsImluZGV4IiwiZG9tTm9kZSIsIkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInBhcmVudEVsZW1lbnQiLCJsb2NhbE5hbWUiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJkaXNhYmxlU21vb3RoU2Nyb2xsRHVyaW5nUm91dGVUcmFuc2l0aW9uIiwic2Nyb2xsSW50b1ZpZXciLCJodG1sRWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudEhlaWdodCIsInNjcm9sbFRvcCIsImRvbnRGb3JjZUxheW91dCIsIm9ubHlIYXNoQ2hhbmdlIiwiZm9jdXMiLCJTY3JvbGxBbmRGb2N1c0hhbmRsZXIiLCJjb250ZXh0IiwidXNlQ29udGV4dCIsIkdsb2JhbExheW91dFJvdXRlckNvbnRleHQiLCJFcnJvciIsIklubmVyTGF5b3V0Um91dGVyIiwidHJlZSIsImRlYnVnTmFtZUNvbnRleHQiLCJjYWNoZU5vZGUiLCJwYXJhbXMiLCJ1cmwiLCJpc0FjdGl2ZSIsInBhcmVudE5hdlByb21pc2VzIiwiTmF2aWdhdGlvblByb21pc2VzQ29udGV4dCIsImZ1bGxUcmVlIiwicmVzb2x2ZWRQcmVmZXRjaFJzYyIsInByZWZldGNoUnNjIiwicnNjIiwidXNlRGVmZXJyZWRWYWx1ZSIsInJlc29sdmVkUnNjIiwidGhlbiIsInVzZSIsImxhenlEYXRhIiwicmVmZXRjaFRyZWUiLCJpbmNsdWRlTmV4dFVybCIsImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSIsIm5hdmlnYXRlZEF0IiwiRGF0ZSIsIm5vdyIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJVUkwiLCJsb2NhdGlvbiIsIm9yaWdpbiIsImZsaWdodFJvdXRlclN0YXRlIiwibmV4dFVybCIsInByZXZpb3VzTmV4dFVybCIsInNlcnZlclJlc3BvbnNlIiwic3RhcnRUcmFuc2l0aW9uIiwiZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24iLCJ0eXBlIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsInByZXZpb3VzVHJlZSIsInVucmVzb2x2ZWRUaGVuYWJsZSIsImNvbnRlbnQiLCJuYXZpZ2F0aW9uUHJvbWlzZXMiLCJjcmVhdGVOZXN0ZWRMYXlvdXROYXZpZ2F0aW9uUHJvbWlzZXMiLCJyZXF1aXJlIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInN1YnRyZWUiLCJMYXlvdXRSb3V0ZXJDb250ZXh0IiwicGFyZW50VHJlZSIsInBhcmVudENhY2hlTm9kZSIsInBhcmVudFNlZ21lbnRQYXRoIiwicGFyZW50UGFyYW1zIiwiTG9hZGluZ0JvdW5kYXJ5IiwibmFtZSIsImxvYWRpbmciLCJsb2FkaW5nTW9kdWxlRGF0YSIsInByb21pc2VGb3JMb2FkaW5nIiwibG9hZGluZ1JzYyIsImxvYWRpbmdTdHlsZXMiLCJsb2FkaW5nU2NyaXB0cyIsIlN1c3BlbnNlIiwiZmFsbGJhY2siLCJwYXJhbGxlbFJvdXRlcktleSIsImVycm9yIiwiZXJyb3JTdHlsZXMiLCJlcnJvclNjcmlwdHMiLCJ0ZW1wbGF0ZVN0eWxlcyIsInRlbXBsYXRlU2NyaXB0cyIsInRlbXBsYXRlIiwibm90Rm91bmQiLCJmb3JiaWRkZW4iLCJ1bmF1dGhvcml6ZWQiLCJzZWdtZW50Vmlld0JvdW5kYXJpZXMiLCJwYXJlbnRQYXJhbGxlbFJvdXRlcyIsInBhcmFsbGVsUm91dGVzIiwic2VnbWVudE1hcCIsImdldCIsIk1hcCIsInNldCIsInBhcmVudFRyZWVTZWdtZW50IiwiY29uY2F0IiwiYWN0aXZlVHJlZSIsImFjdGl2ZVNlZ21lbnQiLCJhY3RpdmVTdGF0ZUtleSIsImNyZWF0ZVJvdXRlckNhY2hlS2V5IiwiYmZjYWNoZUVudHJ5IiwidXNlUm91dGVyQkZDYWNoZSIsInN0YXRlS2V5IiwiY2FjaGVLZXkiLCJuZXdMYXp5Q2FjaGVOb2RlIiwiaGVhZCIsInByZWZldGNoSGVhZCIsInNlZ21lbnRCb3VuZGFyeVRyaWdnZXJOb2RlIiwic2VnbWVudFZpZXdTdGF0ZU5vZGUiLCJTZWdtZW50Qm91bmRhcnlUcmlnZ2VyTm9kZSIsIlNlZ21lbnRWaWV3U3RhdGVOb2RlIiwicGFnZVByZWZpeCIsIm5vcm1hbGl6ZUFwcFBhdGgiLCJwYWdlIiwiQXJyYXkiLCJpc0FycmF5IiwicGFyYW1OYW1lIiwicGFyYW1DYWNoZUtleSIsInBhcmFtVHlwZSIsInBhcmFtVmFsdWUiLCJnZXRQYXJhbVZhbHVlRnJvbUNhY2hlS2V5IiwiZGVidWdOYW1lIiwiZ2V0Qm91bmRhcnlEZWJ1Z05hbWVGcm9tU2VnbWVudCIsImNoaWxkRGVidWdOYW1lQ29udGV4dCIsImlzVmlydHVhbCIsImRlYnVnTmFtZVRvRGlzcGxheSIsImNoaWxkIiwiVGVtcGxhdGVDb250ZXh0IiwiRXJyb3JCb3VuZGFyeSIsImVycm9yQ29tcG9uZW50IiwiSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnkiLCJSZWRpcmVjdEJvdW5kYXJ5IiwiU2VnbWVudFN0YXRlUHJvdmlkZXIiLCJfX05FWFRfQ0FDSEVfQ09NUE9ORU5UUyIsIkFjdGl2aXR5IiwibW9kZSIsInB1c2giLCJuZXh0IiwiaXNWaXJ0dWFsTGF5b3V0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/render-from-template-context.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/render-from-template-context.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return RenderFromTemplateContext;\n    }\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nfunction RenderFromTemplateContext() {\n    const children = (0, _react.useContext)(_approutercontextsharedruntime.TemplateContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c = RenderFromTemplateContext;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=render-from-template-context.js.map\nvar _c;\n$RefreshReg$(_c, \"RenderFromTemplateContext\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7OzJDQUtBOzs7ZUFBd0JBOzs7Ozs2RUFIb0I7MkRBQ1o7QUFFakI7SUFDYixNQUFNQyxXQUFXQyxDQUFBQSxHQUFBQSxPQUFBQSxVQUFBQSxFQUFXQywrQkFBQUEsZUFBZTtJQUMzQyxxQkFBTztrQkFBR0Y7O0FBQ1o7S0FId0JEIiwic291cmNlcyI6WyIvc3JjL2NsaWVudC9jb21wb25lbnRzL3JlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlQ29udGV4dCwgdHlwZSBKU1ggfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFRlbXBsYXRlQ29udGV4dCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSZW5kZXJGcm9tVGVtcGxhdGVDb250ZXh0KCk6IEpTWC5FbGVtZW50IHtcbiAgY29uc3QgY2hpbGRyZW4gPSB1c2VDb250ZXh0KFRlbXBsYXRlQ29udGV4dClcbiAgcmV0dXJuIDw+e2NoaWxkcmVufTwvPlxufVxuIl0sIm5hbWVzIjpbIlJlbmRlckZyb21UZW1wbGF0ZUNvbnRleHQiLCJjaGlsZHJlbiIsInVzZUNvbnRleHQiLCJUZW1wbGF0ZUNvbnRleHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/render-from-template-context.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/request/params.browser.dev.js":
/*!*********************************************************************!*\
  !*** ./node_modules/next/dist/client/request/params.browser.dev.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"createRenderParamsFromClient\", ({\n    enumerable: true,\n    get: function() {\n        return createRenderParamsFromClient;\n    }\n}));\nconst _reflect = __webpack_require__(/*! ../../server/web/spec-extension/adapters/reflect */ \"(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\");\nconst _reflectutils = __webpack_require__(/*! ../../shared/lib/utils/reflect-utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/reflect-utils.js\");\nconst CachedParams = new WeakMap();\nfunction makeDynamicallyTrackedParamsWithDevWarnings(underlyingParams) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    // We don't use makeResolvedReactPromise here because params\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = Promise.resolve(underlyingParams);\n    const proxiedProperties = new Set();\n    Object.keys(underlyingParams).forEach((prop)=>{\n        if (_reflectutils.wellKnownProperties.has(prop)) {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        } else {\n            proxiedProperties.add(prop);\n        }\n    });\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            if (typeof prop === 'string') {\n                if (proxiedProperties.has(prop)) {\n                    const expression = (0, _reflectutils.describeStringPropertyAccess)('params', prop);\n                    warnForSyncAccess(expression);\n                }\n            }\n            return _reflect.ReflectAdapter.get(target, prop, receiver);\n        },\n        set (target, prop, value, receiver) {\n            if (typeof prop === 'string') {\n                proxiedProperties.delete(prop);\n            }\n            return _reflect.ReflectAdapter.set(target, prop, value, receiver);\n        },\n        ownKeys (target) {\n            warnForEnumeration();\n            return Reflect.ownKeys(target);\n        }\n    });\n    CachedParams.set(underlyingParams, proxiedPromise);\n    return proxiedPromise;\n}\nfunction warnForSyncAccess(expression) {\n    console.error(`A param property was accessed directly with ${expression}. ` + `\\`params\\` is a Promise and must be unwrapped with \\`React.use()\\` before accessing its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n}\nfunction warnForEnumeration() {\n    console.error(`params are being enumerated. ` + `\\`params\\` is a Promise and must be unwrapped with \\`React.use()\\` before accessing its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n}\nfunction createRenderParamsFromClient(clientParams) {\n    return makeDynamicallyTrackedParamsWithDevWarnings(clientParams);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=params.browser.dev.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QvcGFyYW1zLmJyb3dzZXIuZGV2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Z0VBZ0ZnQkE7OztlQUFBQTs7O3FDQTlFZTswQ0FJeEI7QUFHUCxNQUFNQyxlQUFlLElBQUlDO0FBRXpCLFNBQVNDLDRDQUNQQyxnQkFBd0I7SUFFeEIsTUFBTUMsZUFBZUosYUFBYUssR0FBRyxDQUFDRjtJQUN0QyxJQUFJQyxjQUFjO1FBQ2hCLE9BQU9BO0lBQ1Q7SUFFQSw0REFBNEQ7SUFDNUQsa0VBQWtFO0lBQ2xFLHFFQUFxRTtJQUNyRSxNQUFNRSxVQUFVQyxRQUFRQyxPQUFPLENBQUNMO0lBRWhDLE1BQU1NLG9CQUFvQixJQUFJQztJQUU5QkMsT0FBT0MsSUFBSSxDQUFDVCxrQkFBa0JVLE9BQU8sQ0FBQyxDQUFDQztRQUNyQyxJQUFJQyxjQUFBQSxtQkFBbUIsQ0FBQ0MsR0FBRyxDQUFDRixPQUFPO1FBQ2pDLGtFQUFrRTtRQUNsRSxrRUFBa0U7UUFDcEUsT0FBTztZQUNMTCxrQkFBa0JRLEdBQUcsQ0FBQ0g7UUFDeEI7SUFDRjtJQUVBLE1BQU1JLGlCQUFpQixJQUFJQyxNQUFNYixTQUFTO1FBQ3hDRCxLQUFJZSxNQUFNLEVBQUVOLElBQUksRUFBRU8sUUFBUTtZQUN4QixJQUFJLE9BQU9QLFNBQVMsVUFBVTtnQkFDNUIsSUFDRSxrQkFDa0JFLEdBQUcsQ0FBQ0YsT0FDdEI7b0JBQ0EsTUFBTVEsYUFBYUMsQ0FBQUEsR0FBQUEsY0FBQUEsNEJBQUFBLEVBQTZCLFVBQVVUO29CQUMxRFUsa0JBQWtCRjtnQkFDcEI7WUFDRjtZQUNBLE9BQU9HLFNBQUFBLGNBQWMsQ0FBQ3BCLEdBQUcsQ0FBQ2UsUUFBUU4sTUFBTU87UUFDMUM7UUFDQUssS0FBSU4sTUFBTSxFQUFFTixJQUFJLEVBQUVhLEtBQUssRUFBRU4sUUFBUTtZQUMvQixJQUFJLE9BQU9QLFNBQVMsVUFBVTtnQkFDNUJMLGtCQUFrQm1CLE1BQU0sQ0FBQ2Q7WUFDM0I7WUFDQSxPQUFPVyxTQUFBQSxjQUFjLENBQUNDLEdBQUcsQ0FBQ04sUUFBUU4sTUFBTWEsT0FBT047UUFDakQ7UUFDQVEsU0FBUVQsTUFBTTtZQUNaVTtZQUNBLE9BQU9DLFFBQVFGLE9BQU8sQ0FBQ1Q7UUFDekI7SUFDRjtJQUVBcEIsYUFBYTBCLEdBQUcsQ0FBQ3ZCLGtCQUFrQmU7SUFDbkMsT0FBT0E7QUFDVDtBQUVBLFNBQVNNLGtCQUFrQkYsVUFBa0I7SUFDM0NVLFFBQVFDLEtBQUssQ0FDWCxDQUFDLDRDQUE0QyxFQUFFWCxXQUFXLEVBQUUsQ0FBQyxHQUMzRCxDQUFDLG9HQUFvRyxDQUFDLEdBQ3RHLENBQUMsOERBQThELENBQUM7QUFFdEU7QUFFQSxTQUFTUTtJQUNQRSxRQUFRQyxLQUFLLENBQ1gsQ0FBQyw2QkFBNkIsQ0FBQyxHQUM3QixDQUFDLG9HQUFvRyxDQUFDLEdBQ3RHLENBQUMsOERBQThELENBQUM7QUFFdEU7QUFFTyxTQUFTbEMsNkJBQ2RtQyxZQUFvQjtJQUVwQixPQUFPaEMsNENBQTRDZ0M7QUFDckQiLCJzb3VyY2VzIjpbIi9zcmMvY2xpZW50L3JlcXVlc3QvcGFyYW1zLmJyb3dzZXIuZGV2LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgUGFyYW1zIH0gZnJvbSAnLi4vLi4vc2VydmVyL3JlcXVlc3QvcGFyYW1zJ1xuXG5pbXBvcnQgeyBSZWZsZWN0QWRhcHRlciB9IGZyb20gJy4uLy4uL3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvcmVmbGVjdCdcbmltcG9ydCB7XG4gIGRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MsXG4gIHdlbGxLbm93blByb3BlcnRpZXMsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvdXRpbHMvcmVmbGVjdC11dGlscydcblxuaW50ZXJmYWNlIENhY2hlTGlmZXRpbWUge31cbmNvbnN0IENhY2hlZFBhcmFtcyA9IG5ldyBXZWFrTWFwPENhY2hlTGlmZXRpbWUsIFByb21pc2U8UGFyYW1zPj4oKVxuXG5mdW5jdGlvbiBtYWtlRHluYW1pY2FsbHlUcmFja2VkUGFyYW1zV2l0aERldldhcm5pbmdzKFxuICB1bmRlcmx5aW5nUGFyYW1zOiBQYXJhbXNcbik6IFByb21pc2U8UGFyYW1zPiB7XG4gIGNvbnN0IGNhY2hlZFBhcmFtcyA9IENhY2hlZFBhcmFtcy5nZXQodW5kZXJseWluZ1BhcmFtcylcbiAgaWYgKGNhY2hlZFBhcmFtcykge1xuICAgIHJldHVybiBjYWNoZWRQYXJhbXNcbiAgfVxuXG4gIC8vIFdlIGRvbid0IHVzZSBtYWtlUmVzb2x2ZWRSZWFjdFByb21pc2UgaGVyZSBiZWNhdXNlIHBhcmFtc1xuICAvLyBzdXBwb3J0cyBjb3B5aW5nIHdpdGggc3ByZWFkIGFuZCB3ZSBkb24ndCB3YW50IHRvIHVubmVjZXNzYXJpbHlcbiAgLy8gaW5zdHJ1bWVudCB0aGUgcHJvbWlzZSB3aXRoIHNwcmVhZGFibGUgcHJvcGVydGllcyBvZiBSZWFjdFByb21pc2UuXG4gIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZXJseWluZ1BhcmFtcylcblxuICBjb25zdCBwcm94aWVkUHJvcGVydGllcyA9IG5ldyBTZXQ8c3RyaW5nPigpXG5cbiAgT2JqZWN0LmtleXModW5kZXJseWluZ1BhcmFtcykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIGlmICh3ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBjYW5ub3QgYmUgc2hhZG93ZWQgYmVjYXVzZSB0aGV5IG5lZWQgdG8gYmUgdGhlXG4gICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICB9IGVsc2Uge1xuICAgICAgcHJveGllZFByb3BlcnRpZXMuYWRkKHByb3ApXG4gICAgfVxuICB9KVxuXG4gIGNvbnN0IHByb3hpZWRQcm9taXNlID0gbmV3IFByb3h5KHByb21pc2UsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgLy8gV2UgYXJlIGFjY2Vzc2luZyBhIHByb3BlcnR5IHRoYXQgd2FzIHByb3hpZWQgdG8gdGhlIHByb21pc2UgaW5zdGFuY2VcbiAgICAgICAgICBwcm94aWVkUHJvcGVydGllcy5oYXMocHJvcClcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MoJ3BhcmFtcycsIHByb3ApXG4gICAgICAgICAgd2FybkZvclN5bmNBY2Nlc3MoZXhwcmVzc2lvbilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmRlbGV0ZShwcm9wKVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLnNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcilcbiAgICB9LFxuICAgIG93bktleXModGFyZ2V0KSB7XG4gICAgICB3YXJuRm9yRW51bWVyYXRpb24oKVxuICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG4gICAgfSxcbiAgfSlcblxuICBDYWNoZWRQYXJhbXMuc2V0KHVuZGVybHlpbmdQYXJhbXMsIHByb3hpZWRQcm9taXNlKVxuICByZXR1cm4gcHJveGllZFByb21pc2Vcbn1cblxuZnVuY3Rpb24gd2FybkZvclN5bmNBY2Nlc3MoZXhwcmVzc2lvbjogc3RyaW5nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgYEEgcGFyYW0gcHJvcGVydHkgd2FzIGFjY2Vzc2VkIGRpcmVjdGx5IHdpdGggJHtleHByZXNzaW9ufS4gYCArXG4gICAgICBgXFxgcGFyYW1zXFxgIGlzIGEgUHJvbWlzZSBhbmQgbXVzdCBiZSB1bndyYXBwZWQgd2l0aCBcXGBSZWFjdC51c2UoKVxcYCBiZWZvcmUgYWNjZXNzaW5nIGl0cyBwcm9wZXJ0aWVzLiBgICtcbiAgICAgIGBMZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9zeW5jLWR5bmFtaWMtYXBpc2BcbiAgKVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRW51bWVyYXRpb24oKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgYHBhcmFtcyBhcmUgYmVpbmcgZW51bWVyYXRlZC4gYCArXG4gICAgICBgXFxgcGFyYW1zXFxgIGlzIGEgUHJvbWlzZSBhbmQgbXVzdCBiZSB1bndyYXBwZWQgd2l0aCBcXGBSZWFjdC51c2UoKVxcYCBiZWZvcmUgYWNjZXNzaW5nIGl0cyBwcm9wZXJ0aWVzLiBgICtcbiAgICAgIGBMZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9zeW5jLWR5bmFtaWMtYXBpc2BcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVuZGVyUGFyYW1zRnJvbUNsaWVudChcbiAgY2xpZW50UGFyYW1zOiBQYXJhbXNcbik6IFByb21pc2U8UGFyYW1zPiB7XG4gIHJldHVybiBtYWtlRHluYW1pY2FsbHlUcmFja2VkUGFyYW1zV2l0aERldldhcm5pbmdzKGNsaWVudFBhcmFtcylcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVSZW5kZXJQYXJhbXNGcm9tQ2xpZW50IiwiQ2FjaGVkUGFyYW1zIiwiV2Vha01hcCIsIm1ha2VEeW5hbWljYWxseVRyYWNrZWRQYXJhbXNXaXRoRGV2V2FybmluZ3MiLCJ1bmRlcmx5aW5nUGFyYW1zIiwiY2FjaGVkUGFyYW1zIiwiZ2V0IiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicHJveGllZFByb3BlcnRpZXMiLCJTZXQiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsInByb3AiLCJ3ZWxsS25vd25Qcm9wZXJ0aWVzIiwiaGFzIiwiYWRkIiwicHJveGllZFByb21pc2UiLCJQcm94eSIsInRhcmdldCIsInJlY2VpdmVyIiwiZXhwcmVzc2lvbiIsImRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MiLCJ3YXJuRm9yU3luY0FjY2VzcyIsIlJlZmxlY3RBZGFwdGVyIiwic2V0IiwidmFsdWUiLCJkZWxldGUiLCJvd25LZXlzIiwid2FybkZvckVudW1lcmF0aW9uIiwiUmVmbGVjdCIsImNvbnNvbGUiLCJlcnJvciIsImNsaWVudFBhcmFtcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/request/params.browser.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/request/params.browser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/client/request/params.browser.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"createRenderParamsFromClient\", ({\n    enumerable: true,\n    get: function() {\n        return createRenderParamsFromClient;\n    }\n}));\nconst createRenderParamsFromClient =  true ? (__webpack_require__(/*! ./params.browser.dev */ \"(app-pages-browser)/./node_modules/next/dist/client/request/params.browser.dev.js\").createRenderParamsFromClient) : 0;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=params.browser.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QvcGFyYW1zLmJyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztnRUFBYUE7OztlQUFBQTs7O0FBQU4sTUFBTUEsK0JBQ1hDLEtBQW9CLEdBQ2ZHLG1LQUM4QixHQUU3QkEsQ0FDNEIiLCJzb3VyY2VzIjpbIi9zcmMvY2xpZW50L3JlcXVlc3QvcGFyYW1zLmJyb3dzZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQgPVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50J1xuICAgID8gKHJlcXVpcmUoJy4vcGFyYW1zLmJyb3dzZXIuZGV2JykgYXMgdHlwZW9mIGltcG9ydCgnLi9wYXJhbXMuYnJvd3Nlci5kZXYnKSlcbiAgICAgICAgLmNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnRcbiAgICA6IChcbiAgICAgICAgcmVxdWlyZSgnLi9wYXJhbXMuYnJvd3Nlci5wcm9kJykgYXMgdHlwZW9mIGltcG9ydCgnLi9wYXJhbXMuYnJvd3Nlci5wcm9kJylcbiAgICAgICkuY3JlYXRlUmVuZGVyUGFyYW1zRnJvbUNsaWVudFxuIl0sIm5hbWVzIjpbImNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJyZXF1aXJlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/request/params.browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/request/search-params.browser.dev.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/client/request/search-params.browser.dev.js ***!
  \****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"createRenderSearchParamsFromClient\", ({\n    enumerable: true,\n    get: function() {\n        return createRenderSearchParamsFromClient;\n    }\n}));\nconst _reflect = __webpack_require__(/*! ../../server/web/spec-extension/adapters/reflect */ \"(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\");\nconst _reflectutils = __webpack_require__(/*! ../../shared/lib/utils/reflect-utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/reflect-utils.js\");\nconst CachedSearchParams = new WeakMap();\nfunction makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams) {\n    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\n    if (cachedSearchParams) {\n        return cachedSearchParams;\n    }\n    const proxiedProperties = new Set();\n    const promise = Promise.resolve(underlyingSearchParams);\n    Object.keys(underlyingSearchParams).forEach((prop)=>{\n        if (_reflectutils.wellKnownProperties.has(prop)) {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        } else {\n            proxiedProperties.add(prop);\n        }\n    });\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            if (typeof prop === 'string') {\n                if (!_reflectutils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor\n                // the underlying searchParams.\n                Reflect.has(target, prop) === false)) {\n                    const expression = (0, _reflectutils.describeStringPropertyAccess)('searchParams', prop);\n                    warnForSyncAccess(expression);\n                }\n            }\n            return _reflect.ReflectAdapter.get(target, prop, receiver);\n        },\n        set (target, prop, value, receiver) {\n            if (typeof prop === 'string') {\n                proxiedProperties.delete(prop);\n            }\n            return Reflect.set(target, prop, value, receiver);\n        },\n        has (target, prop) {\n            if (typeof prop === 'string') {\n                if (!_reflectutils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor\n                // the underlying searchParams.\n                Reflect.has(target, prop) === false)) {\n                    const expression = (0, _reflectutils.describeHasCheckingStringProperty)('searchParams', prop);\n                    warnForSyncAccess(expression);\n                }\n            }\n            return Reflect.has(target, prop);\n        },\n        ownKeys (target) {\n            warnForSyncSpread();\n            return Reflect.ownKeys(target);\n        }\n    });\n    CachedSearchParams.set(underlyingSearchParams, proxiedPromise);\n    return proxiedPromise;\n}\nfunction warnForSyncAccess(expression) {\n    console.error(`A searchParam property was accessed directly with ${expression}. ` + `\\`searchParams\\` is a Promise and must be unwrapped with \\`React.use()\\` before accessing its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n}\nfunction warnForSyncSpread() {\n    console.error(`The keys of \\`searchParams\\` were accessed directly. ` + `\\`searchParams\\` is a Promise and must be unwrapped with \\`React.use()\\` before accessing its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n}\nfunction createRenderSearchParamsFromClient(underlyingSearchParams) {\n    return makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=search-params.browser.dev.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3Qvc2VhcmNoLXBhcmFtcy5icm93c2VyLmRldi5qcyIsIm1hcHBpbmdzIjoiOzs7O3NFQWtHZ0JBOzs7ZUFBQUE7OztxQ0FoR2U7MENBS3hCO0FBR1AsTUFBTUMscUJBQXFCLElBQUlDO0FBRS9CLFNBQVNDLHlDQUNQQyxzQkFBb0M7SUFFcEMsTUFBTUMscUJBQXFCSixtQkFBbUJLLEdBQUcsQ0FBQ0Y7SUFDbEQsSUFBSUMsb0JBQW9CO1FBQ3RCLE9BQU9BO0lBQ1Q7SUFFQSxNQUFNRSxvQkFBb0IsSUFBSUM7SUFDOUIsTUFBTUMsVUFBVUMsUUFBUUMsT0FBTyxDQUFDUDtJQUVoQ1EsT0FBT0MsSUFBSSxDQUFDVCx3QkFBd0JVLE9BQU8sQ0FBQyxDQUFDQztRQUMzQyxJQUFJQyxjQUFBQSxtQkFBbUIsQ0FBQ0MsR0FBRyxDQUFDRixPQUFPO1FBQ2pDLGtFQUFrRTtRQUNsRSxrRUFBa0U7UUFDcEUsT0FBTztZQUNMUixrQkFBa0JXLEdBQUcsQ0FBQ0g7UUFDeEI7SUFDRjtJQUVBLE1BQU1JLGlCQUFpQixJQUFJQyxNQUFNWCxTQUFTO1FBQ3hDSCxLQUFJZSxNQUFNLEVBQUVOLElBQUksRUFBRU8sUUFBUTtZQUN4QixJQUFJLE9BQU9QLFNBQVMsVUFBVTtnQkFDNUIsSUFDRSxDQUFDQyxjQUFBQSxtQkFBbUIsQ0FBQ0MsR0FBRyxDQUFDRixTQUN4QlIsbUJBQWtCVSxHQUFHLENBQUNGLFNBQ3JCLG9FQUFvRTtnQkFDcEUsK0JBQStCO2dCQUMvQlEsUUFBUU4sR0FBRyxDQUFDSSxRQUFRTixVQUFVLE1BQUksRUFDcEM7b0JBQ0EsTUFBTVMsYUFBYUMsQ0FBQUEsR0FBQUEsY0FBQUEsNEJBQUFBLEVBQTZCLGdCQUFnQlY7b0JBQ2hFVyxrQkFBa0JGO2dCQUNwQjtZQUNGO1lBQ0EsT0FBT0csU0FBQUEsY0FBYyxDQUFDckIsR0FBRyxDQUFDZSxRQUFRTixNQUFNTztRQUMxQztRQUNBTSxLQUFJUCxNQUFNLEVBQUVOLElBQUksRUFBRWMsS0FBSyxFQUFFUCxRQUFRO1lBQy9CLElBQUksT0FBT1AsU0FBUyxVQUFVO2dCQUM1QlIsa0JBQWtCdUIsTUFBTSxDQUFDZjtZQUMzQjtZQUNBLE9BQU9RLFFBQVFLLEdBQUcsQ0FBQ1AsUUFBUU4sTUFBTWMsT0FBT1A7UUFDMUM7UUFDQUwsS0FBSUksTUFBTSxFQUFFTixJQUFJO1lBQ2QsSUFBSSxPQUFPQSxTQUFTLFVBQVU7Z0JBQzVCLElBQ0UsQ0FBQ0MsY0FBQUEsbUJBQW1CLENBQUNDLEdBQUcsQ0FBQ0YsU0FDeEJSLENBQUFBLGtCQUFrQlUsR0FBRyxDQUFDRixTQUNyQixvRUFBb0U7Z0JBQ3BFLCtCQUErQjtnQkFDL0JRLFFBQVFOLEdBQUcsQ0FBQ0ksUUFBUU4sVUFBVSxNQUFJLEVBQ3BDO29CQUNBLE1BQU1TLGFBQWFPLENBQUFBLEdBQUFBLGNBQUFBLGlDQUFBQSxFQUNqQixnQkFDQWhCO29CQUVGVyxrQkFBa0JGO2dCQUNwQjtZQUNGO1lBQ0EsT0FBT0QsUUFBUU4sR0FBRyxDQUFDSSxRQUFRTjtRQUM3QjtRQUNBaUIsU0FBUVgsTUFBTTtZQUNaWTtZQUNBLE9BQU9WLFFBQVFTLE9BQU8sQ0FBQ1g7UUFDekI7SUFDRjtJQUVBcEIsbUJBQW1CMkIsR0FBRyxDQUFDeEIsd0JBQXdCZTtJQUMvQyxPQUFPQTtBQUNUO0FBRUEsU0FBU08sa0JBQWtCRixVQUFrQjtJQUMzQ1UsUUFBUUMsS0FBSyxDQUNYLENBQUMsa0RBQWtELEVBQUVYLFdBQVcsRUFBRSxDQUFDLEdBQ2pFLENBQUMsMEdBQTBHLENBQUMsR0FDNUcsQ0FBQyw4REFBOEQsQ0FBQztBQUV0RTtBQUVBLFNBQVNTO0lBQ1BDLFFBQVFDLEtBQUssQ0FDWCxDQUFDLHFEQUFxRCxDQUFDLEdBQ3JELENBQUMsMEdBQTBHLENBQUMsR0FDNUcsQ0FBQyw4REFBOEQsQ0FBQztBQUV0RTtBQUVPLFNBQVNuQyxtQ0FDZEksc0JBQW9DO0lBRXBDLE9BQU9ELHlDQUF5Q0M7QUFDbEQiLCJzb3VyY2VzIjpbIi9zcmMvY2xpZW50L3JlcXVlc3Qvc2VhcmNoLXBhcmFtcy5icm93c2VyLmRldi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3NlYXJjaC1wYXJhbXMnXG5cbmltcG9ydCB7IFJlZmxlY3RBZGFwdGVyIH0gZnJvbSAnLi4vLi4vc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZWZsZWN0J1xuaW1wb3J0IHtcbiAgZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcyxcbiAgZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5LFxuICB3ZWxsS25vd25Qcm9wZXJ0aWVzLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3V0aWxzL3JlZmxlY3QtdXRpbHMnXG5cbmludGVyZmFjZSBDYWNoZUxpZmV0aW1lIHt9XG5jb25zdCBDYWNoZWRTZWFyY2hQYXJhbXMgPSBuZXcgV2Vha01hcDxDYWNoZUxpZmV0aW1lLCBQcm9taXNlPFNlYXJjaFBhcmFtcz4+KClcblxuZnVuY3Rpb24gbWFrZVVudHJhY2tlZFNlYXJjaFBhcmFtc1dpdGhEZXZXYXJuaW5ncyhcbiAgdW5kZXJseWluZ1NlYXJjaFBhcmFtczogU2VhcmNoUGFyYW1zXG4pOiBQcm9taXNlPFNlYXJjaFBhcmFtcz4ge1xuICBjb25zdCBjYWNoZWRTZWFyY2hQYXJhbXMgPSBDYWNoZWRTZWFyY2hQYXJhbXMuZ2V0KHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpXG4gIGlmIChjYWNoZWRTZWFyY2hQYXJhbXMpIHtcbiAgICByZXR1cm4gY2FjaGVkU2VhcmNoUGFyYW1zXG4gIH1cblxuICBjb25zdCBwcm94aWVkUHJvcGVydGllcyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZXJseWluZ1NlYXJjaFBhcmFtcylcblxuICBPYmplY3Qua2V5cyh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgaWYgKHdlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBzaGFkb3dlZCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSB0aGVcbiAgICAgIC8vIHRydWUgdW5kZXJseWluZyB2YWx1ZSBmb3IgUHJvbWlzZXMgdG8gd29yayBjb3JyZWN0bHkgYXQgcnVudGltZVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm94aWVkUHJvcGVydGllcy5hZGQocHJvcClcbiAgICB9XG4gIH0pXG5cbiAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhd2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkgJiZcbiAgICAgICAgICAocHJveGllZFByb3BlcnRpZXMuaGFzKHByb3ApIHx8XG4gICAgICAgICAgICAvLyBXZSBhcmUgYWNjZXNzaW5nIGEgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGV4aXN0IG9uIHRoZSBwcm9taXNlIG5vclxuICAgICAgICAgICAgLy8gdGhlIHVuZGVybHlpbmcgc2VhcmNoUGFyYW1zLlxuICAgICAgICAgICAgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKSA9PT0gZmFsc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzKCdzZWFyY2hQYXJhbXMnLCBwcm9wKVxuICAgICAgICAgIHdhcm5Gb3JTeW5jQWNjZXNzKGV4cHJlc3Npb24pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBwcm94aWVkUHJvcGVydGllcy5kZWxldGUocHJvcClcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcilcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICF3ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSAmJlxuICAgICAgICAgIChwcm94aWVkUHJvcGVydGllcy5oYXMocHJvcCkgfHxcbiAgICAgICAgICAgIC8vIFdlIGFyZSBhY2Nlc3NpbmcgYSBwcm9wZXJ0eSB0aGF0IGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHByb21pc2Ugbm9yXG4gICAgICAgICAgICAvLyB0aGUgdW5kZXJseWluZyBzZWFyY2hQYXJhbXMuXG4gICAgICAgICAgICBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApID09PSBmYWxzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGRlc2NyaWJlSGFzQ2hlY2tpbmdTdHJpbmdQcm9wZXJ0eShcbiAgICAgICAgICAgICdzZWFyY2hQYXJhbXMnLFxuICAgICAgICAgICAgcHJvcFxuICAgICAgICAgIClcbiAgICAgICAgICB3YXJuRm9yU3luY0FjY2VzcyhleHByZXNzaW9uKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKVxuICAgIH0sXG4gICAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICAgIHdhcm5Gb3JTeW5jU3ByZWFkKClcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxuICAgIH0sXG4gIH0pXG5cbiAgQ2FjaGVkU2VhcmNoUGFyYW1zLnNldCh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLCBwcm94aWVkUHJvbWlzZSlcbiAgcmV0dXJuIHByb3hpZWRQcm9taXNlXG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JTeW5jQWNjZXNzKGV4cHJlc3Npb246IHN0cmluZykge1xuICBjb25zb2xlLmVycm9yKFxuICAgIGBBIHNlYXJjaFBhcmFtIHByb3BlcnR5IHdhcyBhY2Nlc3NlZCBkaXJlY3RseSB3aXRoICR7ZXhwcmVzc2lvbn0uIGAgK1xuICAgICAgYFxcYHNlYXJjaFBhcmFtc1xcYCBpcyBhIFByb21pc2UgYW5kIG11c3QgYmUgdW53cmFwcGVkIHdpdGggXFxgUmVhY3QudXNlKClcXGAgYmVmb3JlIGFjY2Vzc2luZyBpdHMgcHJvcGVydGllcy4gYCArXG4gICAgICBgTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvc3luYy1keW5hbWljLWFwaXNgXG4gIClcbn1cblxuZnVuY3Rpb24gd2FybkZvclN5bmNTcHJlYWQoKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgYFRoZSBrZXlzIG9mIFxcYHNlYXJjaFBhcmFtc1xcYCB3ZXJlIGFjY2Vzc2VkIGRpcmVjdGx5LiBgICtcbiAgICAgIGBcXGBzZWFyY2hQYXJhbXNcXGAgaXMgYSBQcm9taXNlIGFuZCBtdXN0IGJlIHVud3JhcHBlZCB3aXRoIFxcYFJlYWN0LnVzZSgpXFxgIGJlZm9yZSBhY2Nlc3NpbmcgaXRzIHByb3BlcnRpZXMuIGAgK1xuICAgICAgYExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3N5bmMtZHluYW1pYy1hcGlzYFxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXNGcm9tQ2xpZW50KFxuICB1bmRlcmx5aW5nU2VhcmNoUGFyYW1zOiBTZWFyY2hQYXJhbXNcbik6IFByb21pc2U8U2VhcmNoUGFyYW1zPiB7XG4gIHJldHVybiBtYWtlVW50cmFja2VkU2VhcmNoUGFyYW1zV2l0aERldldhcm5pbmdzKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpXG59XG4iXSwibmFtZXMiOlsiY3JlYXRlUmVuZGVyU2VhcmNoUGFyYW1zRnJvbUNsaWVudCIsIkNhY2hlZFNlYXJjaFBhcmFtcyIsIldlYWtNYXAiLCJtYWtlVW50cmFja2VkU2VhcmNoUGFyYW1zV2l0aERldldhcm5pbmdzIiwidW5kZXJseWluZ1NlYXJjaFBhcmFtcyIsImNhY2hlZFNlYXJjaFBhcmFtcyIsImdldCIsInByb3hpZWRQcm9wZXJ0aWVzIiwiU2V0IiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJwcm9wIiwid2VsbEtub3duUHJvcGVydGllcyIsImhhcyIsImFkZCIsInByb3hpZWRQcm9taXNlIiwiUHJveHkiLCJ0YXJnZXQiLCJyZWNlaXZlciIsIlJlZmxlY3QiLCJleHByZXNzaW9uIiwiZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcyIsIndhcm5Gb3JTeW5jQWNjZXNzIiwiUmVmbGVjdEFkYXB0ZXIiLCJzZXQiLCJ2YWx1ZSIsImRlbGV0ZSIsImRlc2NyaWJlSGFzQ2hlY2tpbmdTdHJpbmdQcm9wZXJ0eSIsIm93bktleXMiLCJ3YXJuRm9yU3luY1NwcmVhZCIsImNvbnNvbGUiLCJlcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/request/search-params.browser.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/request/search-params.browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/client/request/search-params.browser.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"createRenderSearchParamsFromClient\", ({\n    enumerable: true,\n    get: function() {\n        return createRenderSearchParamsFromClient;\n    }\n}));\nconst createRenderSearchParamsFromClient =  true ? (__webpack_require__(/*! ./search-params.browser.dev */ \"(app-pages-browser)/./node_modules/next/dist/client/request/search-params.browser.dev.js\").createRenderSearchParamsFromClient) : 0;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=search-params.browser.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3Qvc2VhcmNoLXBhcmFtcy5icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7c0VBQWFBOzs7ZUFBQUE7OztBQUFOLE1BQU1BLHFDQUNYQyxLQUFvQixHQUVkRyx1TEFDa0MsR0FFbENBLENBQ2tDIiwic291cmNlcyI6WyIvc3JjL2NsaWVudC9yZXF1ZXN0L3NlYXJjaC1wYXJhbXMuYnJvd3Nlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgY3JlYXRlUmVuZGVyU2VhcmNoUGFyYW1zRnJvbUNsaWVudCA9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnXG4gICAgPyAoXG4gICAgICAgIHJlcXVpcmUoJy4vc2VhcmNoLXBhcmFtcy5icm93c2VyLmRldicpIGFzIHR5cGVvZiBpbXBvcnQoJy4vc2VhcmNoLXBhcmFtcy5icm93c2VyLmRldicpXG4gICAgICApLmNyZWF0ZVJlbmRlclNlYXJjaFBhcmFtc0Zyb21DbGllbnRcbiAgICA6IChcbiAgICAgICAgcmVxdWlyZSgnLi9zZWFyY2gtcGFyYW1zLmJyb3dzZXIucHJvZCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4vc2VhcmNoLXBhcmFtcy5icm93c2VyLnByb2QnKVxuICAgICAgKS5jcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXNGcm9tQ2xpZW50XG4iXSwibmFtZXMiOlsiY3JlYXRlUmVuZGVyU2VhcmNoUGFyYW1zRnJvbUNsaWVudCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInJlcXVpcmUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/request/search-params.browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/lib/metadata/generate/icon-mark.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/lib/metadata/generate/icon-mark.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"IconMark\", ({\n    enumerable: true,\n    get: function() {\n        return IconMark;\n    }\n}));\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst IconMark = ()=>{\n    if (true) {\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n        name: \"\\xabnxt-icon\\xbb\"\n    });\n}; //# sourceMappingURL=icon-mark.js.map\n_c = IconMark;\nvar _c;\n$RefreshReg$(_c, \"IconMark\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbGliL21ldGFkYXRhL2dlbmVyYXRlL2ljb24tbWFyay5qcyIsIm1hcHBpbmdzIjoiOzs7OzRDQVFhQTs7O2VBQUFBOzs7O0FBQU4saUJBQWlCO0lBQ3RCLElBQUksSUFBNkIsRUFBRTtRQUNqQyxPQUFPO0lBQ1Q7SUFDQSxxQkFBTyxxQkFBQ0UsUUFBQUE7UUFBS0MsTUFBSzs7QUFDcEI7S0FMYUgiLCJzb3VyY2VzIjpbIi9zcmMvbGliL21ldGFkYXRhL2dlbmVyYXRlL2ljb24tbWFyay50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbi8vIFRoaXMgaXMgYSBjbGllbnQgY29tcG9uZW50IHRoYXQgb25seSByZW5kZXJzIGR1cmluZyBTU1IsXG4vLyBidXQgd2lsbCBiZSByZXBsYWNlZCBkdXJpbmcgc3RyZWFtaW5nIHdpdGggYW4gaWNvbiBpbnNlcnRpb24gc2NyaXB0IHRhZy5cbi8vIFdlIGRvbid0IHdhbnQgaXQgdG8gYmUgcHJlc2VudGVkIGFueXdoZXJlIHNvIGl0J3Mgb25seSB2aXNpYmxlIGR1cmluZyBzdHJlYW1pbmcsXG4vLyByaWdodCBhZnRlciB0aGUgaWNvbiBtZXRhIHRhZ3Mgc28gdGhhdCBicm93c2VyIGNhbiBwaWNrIGl0IHVwIGFzIHNvb24gYXMgaXQncyByZW5kZXJlZC5cbi8vIE5vdGU6IHdlIGRvbid0IGp1c3QgZW1pdCB0aGUgc2NyaXB0IGhlcmUgYmVjYXVzZSB3ZSBvbmx5IG5lZWQgdGhlIHNjcmlwdCBpZiBpdCdzIG5vdCBpbiB0aGUgaGVhZCxcbi8vIGFuZCB3ZSBuZWVkIGl0IHRvIGJlIGhvaXN0YWJsZSBhbG9uZ3NpZGUgdGhlIG90aGVyIG1ldGFkYXRhIGJ1dCBzeW5jIHNjcmlwdHMgYXJlIG5vdCBob2lzdGFibGUuXG5leHBvcnQgY29uc3QgSWNvbk1hcmsgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgcmV0dXJuIDxtZXRhIG5hbWU9XCLCq254dC1pY29uwrtcIiAvPlxufVxuIl0sIm5hbWVzIjpbIkljb25NYXJrIiwid2luZG93IiwibWV0YSIsIm5hbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/lib/metadata/generate/icon-mark.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ReflectAdapter\", ({\n    enumerable: true,\n    get: function() {\n        return ReflectAdapter;\n    }\n}));\nclass ReflectAdapter {\n    static get(target, prop, receiver) {\n        const value = Reflect.get(target, prop, receiver);\n        if (typeof value === 'function') {\n            return value.bind(target);\n        }\n        return value;\n    }\n    static set(target, prop, value, receiver) {\n        return Reflect.set(target, prop, value, receiver);\n    }\n    static has(target, prop) {\n        return Reflect.has(target, prop);\n    }\n    static deleteProperty(target, prop) {\n        return Reflect.deleteProperty(target, prop);\n    }\n}\n\n//# sourceMappingURL=reflect.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZWZsZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZWZsZWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVmbGVjdEFkYXB0ZXJcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyO1xuICAgIH1cbn0pO1xuY2xhc3MgUmVmbGVjdEFkYXB0ZXIge1xuICAgIHN0YXRpYyBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuYmluZCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc3RhdGljIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICB9XG4gICAgc3RhdGljIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApO1xuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmbGVjdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js ***!
  \*********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"disableSmoothScrollDuringRouteTransition\", ({\n    enumerable: true,\n    get: function() {\n        return disableSmoothScrollDuringRouteTransition;\n    }\n}));\nconst _warnonce = __webpack_require__(/*! ../../utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction disableSmoothScrollDuringRouteTransition(fn, options = {}) {\n    // if only the hash is changed, we don't need to disable smooth scrolling\n    // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX\n    if (options.onlyHashChange) {\n        fn();\n        return;\n    }\n    const htmlElement = document.documentElement;\n    const hasDataAttribute = htmlElement.dataset.scrollBehavior === 'smooth';\n    if (!hasDataAttribute) {\n        // Warn if smooth scrolling is detected but no data attribute is present\n        if ( true && getComputedStyle(htmlElement).scrollBehavior === 'smooth') {\n            (0, _warnonce.warnOnce)('Detected `scroll-behavior: smooth` on the `<html>` element. To disable smooth scrolling during route transitions, ' + 'add `data-scroll-behavior=\"smooth\"` to your <html> element. ' + 'Learn more: https://nextjs.org/docs/messages/missing-data-scroll-behavior');\n        }\n        // No smooth scrolling configured, run directly without style manipulation\n        fn();\n        return;\n    }\n    // Proceed with temporarily disabling smooth scrolling\n    const existing = htmlElement.style.scrollBehavior;\n    htmlElement.style.scrollBehavior = 'auto';\n    if (!options.dontForceLayout) {\n        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\n        // Otherwise it will not pickup the change in scrollBehavior\n        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\n        htmlElement.getClientRects();\n    }\n    fn();\n    htmlElement.style.scrollBehavior = existing;\n} //# sourceMappingURL=disable-smooth-scroll.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZGlzYWJsZS1zbW9vdGgtc2Nyb2xsLmpzIiwibWFwcGluZ3MiOiI7Ozs7NEVBTWdCQTs7O2VBQUFBOzs7c0NBTlM7QUFNbEIsU0FBU0EseUNBQ2RDLEVBQWMsRUFDZEMsVUFBbUUsQ0FBQyxDQUFDO0lBRXJFLHlFQUF5RTtJQUN6RSw2RkFBNkY7SUFDN0YsSUFBSUEsUUFBUUMsY0FBYyxFQUFFO1FBQzFCRjtRQUNBO0lBQ0Y7SUFFQSxNQUFNRyxjQUFjQyxTQUFTQyxlQUFlO0lBQzVDLE1BQU1DLG1CQUFtQkgsWUFBWUksT0FBTyxDQUFDQyxjQUFjLEtBQUs7SUFFaEUsSUFBSSxDQUFDRixrQkFBa0I7UUFDckIsd0VBQXdFO1FBQ3hFLElBQ0VHLEtBQW9CLElBQ3BCRyxpQkFBaUJULGFBQWFLLGNBQWMsS0FBSyxVQUNqRDtZQUNBSyxDQUFBQSxHQUFBQSxVQUFBQSxRQUFBQSxFQUNFLHVIQUNFLGlFQUNBO1FBRU47UUFDQSwwRUFBMEU7UUFDMUViO1FBQ0E7SUFDRjtJQUVBLHNEQUFzRDtJQUN0RCxNQUFNYyxXQUFXWCxZQUFZWSxLQUFLLENBQUNQLGNBQWM7SUFDakRMLFlBQVlZLEtBQUssQ0FBQ1AsY0FBYyxHQUFHO0lBQ25DLElBQUksQ0FBQ1AsUUFBUWUsZUFBZSxFQUFFO1FBQzVCLDhFQUE4RTtRQUM5RSw0REFBNEQ7UUFDNUQseUZBQXlGO1FBQ3pGYixZQUFZYyxjQUFjO0lBQzVCO0lBQ0FqQjtJQUNBRyxZQUFZWSxLQUFLLENBQUNQLGNBQWMsR0FBR007QUFDckMiLCJzb3VyY2VzIjpbIi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZGlzYWJsZS1zbW9vdGgtc2Nyb2xsLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvd2Fybi1vbmNlJ1xuXG4vKipcbiAqIFJ1biBmdW5jdGlvbiB3aXRoIGBzY3JvbGwtYmVoYXZpb3I6IGF1dG9gIGFwcGxpZWQgdG8gYDxodG1sLz5gLlxuICogVGhpcyBjc3MgY2hhbmdlIHdpbGwgYmUgcmV2ZXJ0ZWQgYWZ0ZXIgdGhlIGZ1bmN0aW9uIGZpbmlzaGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZVNtb290aFNjcm9sbER1cmluZ1JvdXRlVHJhbnNpdGlvbihcbiAgZm46ICgpID0+IHZvaWQsXG4gIG9wdGlvbnM6IHsgZG9udEZvcmNlTGF5b3V0PzogYm9vbGVhbjsgb25seUhhc2hDaGFuZ2U/OiBib29sZWFuIH0gPSB7fVxuKSB7XG4gIC8vIGlmIG9ubHkgdGhlIGhhc2ggaXMgY2hhbmdlZCwgd2UgZG9uJ3QgbmVlZCB0byBkaXNhYmxlIHNtb290aCBzY3JvbGxpbmdcbiAgLy8gd2Ugb25seSBjYXJlIHRvIHByZXZlbnQgc21vb3RoIHNjcm9sbGluZyB3aGVuIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZSB0byBhdm9pZCBqYXJyaW5nIFVYXG4gIGlmIChvcHRpb25zLm9ubHlIYXNoQ2hhbmdlKSB7XG4gICAgZm4oKVxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgaHRtbEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbiAgY29uc3QgaGFzRGF0YUF0dHJpYnV0ZSA9IGh0bWxFbGVtZW50LmRhdGFzZXQuc2Nyb2xsQmVoYXZpb3IgPT09ICdzbW9vdGgnXG5cbiAgaWYgKCFoYXNEYXRhQXR0cmlidXRlKSB7XG4gICAgLy8gV2FybiBpZiBzbW9vdGggc2Nyb2xsaW5nIGlzIGRldGVjdGVkIGJ1dCBubyBkYXRhIGF0dHJpYnV0ZSBpcyBwcmVzZW50XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgIGdldENvbXB1dGVkU3R5bGUoaHRtbEVsZW1lbnQpLnNjcm9sbEJlaGF2aW9yID09PSAnc21vb3RoJ1xuICAgICkge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgICdEZXRlY3RlZCBgc2Nyb2xsLWJlaGF2aW9yOiBzbW9vdGhgIG9uIHRoZSBgPGh0bWw+YCBlbGVtZW50LiBUbyBkaXNhYmxlIHNtb290aCBzY3JvbGxpbmcgZHVyaW5nIHJvdXRlIHRyYW5zaXRpb25zLCAnICtcbiAgICAgICAgICAnYWRkIGBkYXRhLXNjcm9sbC1iZWhhdmlvcj1cInNtb290aFwiYCB0byB5b3VyIDxodG1sPiBlbGVtZW50LiAnICtcbiAgICAgICAgICAnTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbWlzc2luZy1kYXRhLXNjcm9sbC1iZWhhdmlvcidcbiAgICAgIClcbiAgICB9XG4gICAgLy8gTm8gc21vb3RoIHNjcm9sbGluZyBjb25maWd1cmVkLCBydW4gZGlyZWN0bHkgd2l0aG91dCBzdHlsZSBtYW5pcHVsYXRpb25cbiAgICBmbigpXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBQcm9jZWVkIHdpdGggdGVtcG9yYXJpbHkgZGlzYWJsaW5nIHNtb290aCBzY3JvbGxpbmdcbiAgY29uc3QgZXhpc3RpbmcgPSBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvclxuICBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9ICdhdXRvJ1xuICBpZiAoIW9wdGlvbnMuZG9udEZvcmNlTGF5b3V0KSB7XG4gICAgLy8gSW4gQ2hyb21lLWJhc2VkIGJyb3dzZXJzIHdlIG5lZWQgdG8gZm9yY2UgcmVmbG93IGJlZm9yZSBjYWxsaW5nIGBzY3JvbGxUb2AuXG4gICAgLy8gT3RoZXJ3aXNlIGl0IHdpbGwgbm90IHBpY2t1cCB0aGUgY2hhbmdlIGluIHNjcm9sbEJlaGF2aW9yXG4gICAgLy8gTW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9pc3N1ZXMvNDA3MTkjaXNzdWVjb21tZW50LTEzMzYyNDgwNDJcbiAgICBodG1sRWxlbWVudC5nZXRDbGllbnRSZWN0cygpXG4gIH1cbiAgZm4oKVxuICBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IGV4aXN0aW5nXG59XG4iXSwibmFtZXMiOlsiZGlzYWJsZVNtb290aFNjcm9sbER1cmluZ1JvdXRlVHJhbnNpdGlvbiIsImZuIiwib3B0aW9ucyIsIm9ubHlIYXNoQ2hhbmdlIiwiaHRtbEVsZW1lbnQiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImhhc0RhdGFBdHRyaWJ1dGUiLCJkYXRhc2V0Iiwic2Nyb2xsQmVoYXZpb3IiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJnZXRDb21wdXRlZFN0eWxlIiwid2Fybk9uY2UiLCJleGlzdGluZyIsInN0eWxlIiwiZG9udEZvcmNlTGF5b3V0IiwiZ2V0Q2xpZW50UmVjdHMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/reflect-utils.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils/reflect-utils.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("// This regex will have fast negatives meaning valid identifiers may not pass\n// this test. However this is only used during static generation to provide hints\n// about why a page bailed out of some or all prerendering and we can use bracket notation\n// for example while `ಠ_ಠ` is a valid identifier it's ok to print `searchParams['ಠ_ಠ']`\n// even if this would have been fine too `searchParams.ಠ_ಠ`\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    describeHasCheckingStringProperty: function() {\n        return describeHasCheckingStringProperty;\n    },\n    describeStringPropertyAccess: function() {\n        return describeStringPropertyAccess;\n    },\n    wellKnownProperties: function() {\n        return wellKnownProperties;\n    }\n});\nconst isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/;\nfunction describeStringPropertyAccess(target, prop) {\n    if (isDefinitelyAValidIdentifier.test(prop)) {\n        return `\\`${target}.${prop}\\``;\n    }\n    return `\\`${target}[${JSON.stringify(prop)}]\\``;\n}\nfunction describeHasCheckingStringProperty(target, prop) {\n    const stringifiedProp = JSON.stringify(prop);\n    return `\\`Reflect.has(${target}, ${stringifiedProp})\\`, \\`${stringifiedProp} in ${target}\\`, or similar`;\n}\nconst wellKnownProperties = new Set([\n    'hasOwnProperty',\n    'isPrototypeOf',\n    'propertyIsEnumerable',\n    'toString',\n    'valueOf',\n    'toLocaleString',\n    // Promise prototype\n    'then',\n    'catch',\n    'finally',\n    // React Promise extension\n    'status',\n    // 'value',\n    // 'error',\n    // React introspection\n    'displayName',\n    '_debugInfo',\n    // Common tested properties\n    'toJSON',\n    '$$typeof',\n    '__esModule'\n]); //# sourceMappingURL=reflect-utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy9yZWZsZWN0LXV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBLDZFQUE2RTtBQUM3RSxpRkFBaUY7QUFDakYsMEZBQTBGO0FBQzFGLHVGQUF1RjtBQUN2RiwyREFBMkQ7Ozs7Ozs7Ozs7Ozs7SUFVM0NBLGlDQUFpQztlQUFqQ0E7O0lBUEFDLDRCQUE0QjtlQUE1QkE7O0lBZUhDLG1CQUFtQjtlQUFuQkE7OztBQWpCYixNQUFNQywrQkFBK0I7QUFFOUIsU0FBU0YsNkJBQTZCRyxNQUFjLEVBQUVDLElBQVk7SUFDdkUsSUFBSUYsNkJBQTZCRyxJQUFJLENBQUNELE9BQU87UUFDM0MsT0FBTyxDQUFDLEVBQUUsRUFBRUQsT0FBTyxDQUFDLEVBQUVDLEtBQUssRUFBRSxDQUFDO0lBQ2hDO0lBQ0EsT0FBTyxDQUFDLEVBQUUsRUFBRUQsT0FBTyxDQUFDLEVBQUVHLEtBQUtDLFNBQVMsQ0FBQ0gsTUFBTSxHQUFHLENBQUM7QUFDakQ7QUFFTyxTQUFTTCxrQ0FDZEksTUFBYyxFQUNkQyxJQUFZO0lBRVosTUFBTUksa0JBQWtCRixLQUFLQyxTQUFTLENBQUNIO0lBQ3ZDLE9BQU8sQ0FBQyxjQUFjLEVBQUVELE9BQU8sRUFBRSxFQUFFSyxnQkFBZ0IsT0FBTyxFQUFFQSxnQkFBZ0IsSUFBSSxFQUFFTCxPQUFPLGNBQWMsQ0FBQztBQUMxRztBQUVPLE1BQU1GLHNCQUFzQixJQUFJUSxJQUFJO0lBQ3pDO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUVBLG9CQUFvQjtJQUNwQjtJQUNBO0lBQ0E7SUFFQSwwQkFBMEI7SUFDMUI7SUFDQSxXQUFXO0lBQ1gsV0FBVztJQUVYLHNCQUFzQjtJQUN0QjtJQUNBO0lBRUEsMkJBQTJCO0lBQzNCO0lBQ0E7SUFDQTtDQUNEIiwic291cmNlcyI6WyIvc3JjL3NoYXJlZC9saWIvdXRpbHMvcmVmbGVjdC11dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIHJlZ2V4IHdpbGwgaGF2ZSBmYXN0IG5lZ2F0aXZlcyBtZWFuaW5nIHZhbGlkIGlkZW50aWZpZXJzIG1heSBub3QgcGFzc1xuLy8gdGhpcyB0ZXN0LiBIb3dldmVyIHRoaXMgaXMgb25seSB1c2VkIGR1cmluZyBzdGF0aWMgZ2VuZXJhdGlvbiB0byBwcm92aWRlIGhpbnRzXG4vLyBhYm91dCB3aHkgYSBwYWdlIGJhaWxlZCBvdXQgb2Ygc29tZSBvciBhbGwgcHJlcmVuZGVyaW5nIGFuZCB3ZSBjYW4gdXNlIGJyYWNrZXQgbm90YXRpb25cbi8vIGZvciBleGFtcGxlIHdoaWxlIGDgsqBf4LKgYCBpcyBhIHZhbGlkIGlkZW50aWZpZXIgaXQncyBvayB0byBwcmludCBgc2VhcmNoUGFyYW1zWyfgsqBf4LKgJ11gXG4vLyBldmVuIGlmIHRoaXMgd291bGQgaGF2ZSBiZWVuIGZpbmUgdG9vIGBzZWFyY2hQYXJhbXMu4LKgX+CyoGBcbmNvbnN0IGlzRGVmaW5pdGVseUFWYWxpZElkZW50aWZpZXIgPSAvXltBLVphLXpfJF1bQS1aYS16MC05XyRdKiQvXG5cbmV4cG9ydCBmdW5jdGlvbiBkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzKHRhcmdldDogc3RyaW5nLCBwcm9wOiBzdHJpbmcpIHtcbiAgaWYgKGlzRGVmaW5pdGVseUFWYWxpZElkZW50aWZpZXIudGVzdChwcm9wKSkge1xuICAgIHJldHVybiBgXFxgJHt0YXJnZXR9LiR7cHJvcH1cXGBgXG4gIH1cbiAgcmV0dXJuIGBcXGAke3RhcmdldH1bJHtKU09OLnN0cmluZ2lmeShwcm9wKX1dXFxgYFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5KFxuICB0YXJnZXQ6IHN0cmluZyxcbiAgcHJvcDogc3RyaW5nXG4pIHtcbiAgY29uc3Qgc3RyaW5naWZpZWRQcm9wID0gSlNPTi5zdHJpbmdpZnkocHJvcClcbiAgcmV0dXJuIGBcXGBSZWZsZWN0Lmhhcygke3RhcmdldH0sICR7c3RyaW5naWZpZWRQcm9wfSlcXGAsIFxcYCR7c3RyaW5naWZpZWRQcm9wfSBpbiAke3RhcmdldH1cXGAsIG9yIHNpbWlsYXJgXG59XG5cbmV4cG9ydCBjb25zdCB3ZWxsS25vd25Qcm9wZXJ0aWVzID0gbmV3IFNldChbXG4gICdoYXNPd25Qcm9wZXJ0eScsXG4gICdpc1Byb3RvdHlwZU9mJyxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvU3RyaW5nJyxcbiAgJ3ZhbHVlT2YnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuXG4gIC8vIFByb21pc2UgcHJvdG90eXBlXG4gICd0aGVuJyxcbiAgJ2NhdGNoJyxcbiAgJ2ZpbmFsbHknLFxuXG4gIC8vIFJlYWN0IFByb21pc2UgZXh0ZW5zaW9uXG4gICdzdGF0dXMnLFxuICAvLyAndmFsdWUnLFxuICAvLyAnZXJyb3InLFxuXG4gIC8vIFJlYWN0IGludHJvc3BlY3Rpb25cbiAgJ2Rpc3BsYXlOYW1lJyxcbiAgJ19kZWJ1Z0luZm8nLFxuXG4gIC8vIENvbW1vbiB0ZXN0ZWQgcHJvcGVydGllc1xuICAndG9KU09OJyxcbiAgJyQkdHlwZW9mJyxcbiAgJ19fZXNNb2R1bGUnLFxuXSlcbiJdLCJuYW1lcyI6WyJkZXNjcmliZUhhc0NoZWNraW5nU3RyaW5nUHJvcGVydHkiLCJkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzIiwid2VsbEtub3duUHJvcGVydGllcyIsImlzRGVmaW5pdGVseUFWYWxpZElkZW50aWZpZXIiLCJ0YXJnZXQiLCJwcm9wIiwidGVzdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdHJpbmdpZmllZFByb3AiLCJTZXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/reflect-utils.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fbuiltin%2Fglobal-error.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-segment.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fhttp-access-fallback%2Ferror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Flib%2Fframework%2Fboundary-components.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Flib%2Fmetadata%2Fgenerate%2Ficon-mark.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fnode_modules%2Fnext%2Fdist%2Fnext-devtools%2Fuserspace%2Fapp%2Fsegment-explorer-node.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);